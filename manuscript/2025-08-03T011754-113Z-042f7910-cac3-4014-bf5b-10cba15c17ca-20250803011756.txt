---
author: Peter Armstrong
date: 2017-04-09
identifier: "https://leanpub.com/programmingforkids-material"
language: en
publisher: leanpub.com
title: Material for Programming for Kids
---

[]

[]{#title_page.xhtml}

 {#title_page.xhtml#text-cover}
 

## Material for Programming for Kids

## 

 

### Peter Armstrong


[]{#verso_page.xhtml}

## Material for Programming for Kids

 

#### Peter Armstrong

 

This course is for sale at <http://localhost:3001/c/programmingforkids>

This version was published on 2025-07-16


![publisher's logo](resources/2025-08-03T011754-113Z-042f7910-cac3-4014-bf5b-10cba15c17ca-20250803011756/resources/leanpub-logo.png)


\*   \*   \*   \*   \*

This is a [Leanpub](https://leanpub.com) course. Leanpub empowers authors and publishers with the Lean Publishing process. [Lean Publishing](https://leanpub.com/manifesto) is the act of publishing an in-progress book or course using lightweight tools and many iterations to get reader feedback, pivot until you have the right book or course, and build traction once you do.

\*   \*   \*   \*   \*

 cc-license
[

![Creative Commons by-nd](resources/2025-08-03T011754-113Z-042f7910-cac3-4014-bf5b-10cba15c17ca-20250803011756/resources/cc-by-nd.png)

](http://creativecommons.org/licenses/by-nd//deed.en_US)

This work is licensed under a [Creative Commons Attribution-NoDerivatives](http://creativecommons.org/licenses/by-nd//deed.en_US)


[]{#toc.xhtml}

 
## Table of Contents {#toc.xhtml#toc}

```{=html}
<nav xmlns:epub="http://www.idpf.org/2007/ops" epub:type="landmarks" id="guide">
```
## Guide

1.  [Begin Reading](#chap00.xhtml){.bodymatter}

```{=html}
</nav>
```


[]{#chap00.xhtml}

<div>

# Lesson 0: Introduction 

## For Kids 

This course will get you started learning how to write computer programs!

Writing computer programs, called "programming" or "coding", is a genuinely fun thing to do. You get to solve puzzles and build things. If you work hard, it can be very rewarding.

You will need to use a Mac computer to follow along. The examples are short, so you can type them all in yourself. This is true even if you can't type well.

This course has a bunch of small lessons. Each lesson is about one idea.

At the end of every lesson, there will be exercises for you to do. It is really important that you do all of them! Doing the exercises ensures that you know the material in the lesson. The answers for all the exercises are in the back of the course, and there are links to the answers for all the exercises.

If your parents want to find out more about this course, they can read it with you. Or, they can just read the For Parents section below.

If you're going to use their computer, they might want to sit with you. That's fine. They'll learn something too!

If you are following along on your Mac, you want to follow along with the course in a web browser. You can either use Safari or Google Chrome.

You will be switching back and forth between reading this course in your web browser and typing stuff in Terminal. If you have clicked on your browser window to read, you will need to click on the Terminal window to focus it before typing any commands in Terminal.

Let's get started! Click ["Lesson 1: Hello, Command Line"](#chap00.xhtml#lesson1) to skip to the first lesson, or read what I'm telling your parents about the course below if you're curious.

## For Parents 

This is a course for you to read with your child, or for your child to read by himself or herself.

It is heavily based on a book, [Programming for Kids](https://leanpub.com/programmingforkids), which I wrote to teach my 9 year old son the basics of programming. He had been playing video games for years, and he wanted to learn programming since he wanted to make his own video games someday. This course is intended to be the first step. (No, it doesn't teach you how to create the kinds of video games a 9 year old can dream up; that takes a lot more knowledge!)

This course exists to show kids that they can program computers, and to help them get started. I want it to be the best course in the world for a kid who is wanting to learn to program computers to do first.

I'm also writing another [book](https://leanpub.com/programmingforteens) and [course](https://leanpub.com/c/programmingforteens) for older kids (ages 13-17) called Programming for Teens. That book and course teach some of the same material as this course does, and as the book that this is based on. However, it's written for kids who are slightly older. Also, that course can be done using a Mac, Windows or Linux computer, or even a Chromebook--all it requires is Google Chrome.

This course, on the other hand, requires a Mac. In my opinion, a Mac is the best computer to learn programming on: you have Terminal and easy access to the local filesystem (unlike a Chromebook), the UI is easy to use (unlike some versions of Linux), and the underlying OS is based on UNIX (unlike Windows). Since this is a beginner course for kids, I can't write it generically to cover Mac, Windows and Linux. I have to pick one operating system, and have the child follow along verbatim. Also, you can't save files locally on a Chromebook, so teaching programming on a Chromebook requires a totally different approach.

So, if you have a Mac, I recommend you do this course first, then move on to the [Programming for Teens course](https://leanpub.com/c/programmingforteens) if you liked this one.

The reason for the age difference between this course and Programming for Teens is that my son was the intended reader of both. I started writing the book which this course is based on when he was 9, and I'm writing the Programming for Teens book and course when he is a teenager. Right now, the 9 year old version of him is a distant memory.

Computer programming is a good skill to have, regardless of what occupation your child eventually does as an adult. (I'd argue it's much more important than lots of the math than you learn in high school, for example.) But more importantly, learning how to program computers teaches a rigour and discipline of thinking which is useful in any field.

No knowledge of programming is assumed. The examples are as short as possible, since I assume the reader can't type well. (My son couldn't touch type when he followed along with my book, so if I made long examples I would have heard complaints!)

Besides teaching programming, the course also teaches basic use of the command line on a Mac. This is accessed via the Terminal program. The reason for this is that I feel that the best way to learn is to follow along, and the simplest way to follow along is to type everything. Real programmers use the command line every day. If you want to learn programming, you should use Terminal and files.

If you are letting your child use your Mac computer to follow along, I strongly recommend you sit beside them and follow along! For example, I'm not planning to teach the command to delete files, but it's fairly short!

The examples are in Ruby. Ruby is a fairly simple programming language. If you've ever heard of websites built on "Ruby on Rails", you've heard of Ruby: it's the programming language that Rails is written in. This is not a course about how to learn Ruby, however. The examples could have easily been written in JavaScript, CoffeeScript or Python.

Finally, I really want your feedback! Did your child get stuck anywhere? If you have anything to say about the course, I want to hear it! Please email me at peter@leanpub.com and let me know!

</div>

[]{#chap01.xhtml}

<div>

# Lesson 1: Hello, Command Line! 

## Material 

This lesson is about the command line!

This course is for kids like you who use a Mac computer, either at home or at school.

Normally you use a Mac by clicking on stuff with a mouse. In this lesson you will learn a different way to use a Mac. It is called the command line, and you just use the keyboard.

A command line looks really basic, but it's the most powerful tool on any computer.

Once upon a time, about 35 years ago, all computers had was a command line.

Even though the command line is simple, it is also very powerful. If you know how to use it, you will be like a wizard who can type strange spells and make your computer do amazing things.

Relax, it's not scary. If you get something wrong, you won't break anything!

First we need to learn the basics.

You already know what a keyboard is. But there may be some keys you may not have used before. These are the Command, Option, Control and Shift keys.

 
<figure class="image block">
<img src="resources/2025-08-03T011754-113Z-042f7910-cac3-4014-bf5b-10cba15c17ca-20250803011756/resources/images----keys_selected.png" />
<figcaption>The Command, Option, Control and Shift Keys</figcaption>
</figure>


We are going to start a program called Terminal. Terminal is what lets you use the command line on your Mac.

To start Terminal, hold down the Command key and press the Space bar. (A shorter way of saying this is to say "type `Command + Space`". So, that's what I will say from now on.)

Typing `Command + Space` opens a program called Spotlight in the top right corner of your screen.

 
<figure class="image block">
<img src="resources/2025-08-03T011754-113Z-042f7910-cac3-4014-bf5b-10cba15c17ca-20250803011756/resources/images----spotlight.png" />
<figcaption>Spotlight</figcaption>
</figure>


Spotlight lets you type the names of programs to run.

We are going to run Terminal. So, type `terminal` in Spotlight and hit the Enter key.

You might see it show up in a drop down list after you type `term`. If so, you can just click on that choice instead of finishing typing `terminal`.

 
<figure class="image block">
<img src="resources/2025-08-03T011754-113Z-042f7910-cac3-4014-bf5b-10cba15c17ca-20250803011756/resources/images----spotlightterminal.png" />
<figcaption>Running Terminal</figcaption>
</figure>


You will see Terminal, which will look something like this.

 
<figure class="image block">
<img src="resources/2025-08-03T011754-113Z-042f7910-cac3-4014-bf5b-10cba15c17ca-20250803011756/resources/images----terminal.png" />
<figcaption>Terminal</figcaption>
</figure>


Terminal is the command line of the Mac.

(Don't worry about the ~\[\]\$\ stuff\ at\ the\ beginning\ of\ the\ line.\ That's\ just\ what\ the\ "prompt"\ looks\ like\ on\ my\ computer,\ and\ it\ is\ possible\ to\ customize\ your\ prompt.\ Your\ prompt\ might\ look\ like\ \>\ or~.)

Before we get started, let's have the command line say hello to us. To do this, we're going to run the `say` program.

Type `say hello` in Terminal.

 
<figure class="image block">
<img src="resources/2025-08-03T011754-113Z-042f7910-cac3-4014-bf5b-10cba15c17ca-20250803011756/resources/images----say_hello.png" />
</figure>


Then, press the `Enter` key to run the command.

 
<figure class="image block">
<img src="resources/2025-08-03T011754-113Z-042f7910-cac3-4014-bf5b-10cba15c17ca-20250803011756/resources/images----say_hello2.png" />
</figure>


Hopefully your Mac said hello to you! If not, make sure the volume is on and try that again.

By the way, after entering any command in Terminal you need to hit Enter to run it.

Now, let's start by making a folder for all the stuff we are going to do in this course. Type `mkdir stuff` in Terminal and hit Enter.

 
<figure class="image block">
<img src="resources/2025-08-03T011754-113Z-042f7910-cac3-4014-bf5b-10cba15c17ca-20250803011756/resources/images----hellocmdline002.png" />
</figure>


The command `mkdir` is said "make dir" and stands for "make directory". Directory is another word for folder. So, you just made a folder called `stuff`.

Next, we are going to go into that folder. Type `cd stuff` in Terminal and hit Enter.

 
<figure class="image block">
<img src="resources/2025-08-03T011754-113Z-042f7910-cac3-4014-bf5b-10cba15c17ca-20250803011756/resources/images----hellocmdline003.png" />
</figure>


The `cd` command stands for "change directory". So, you are changing into the directory called stuff that you just made.

Let's look inside this directory. In Terminal, type `ls` (a lowercase L and a lowercase S) and hit Enter.

 
<figure class="image block">
<img src="resources/2025-08-03T011754-113Z-042f7910-cac3-4014-bf5b-10cba15c17ca-20250803011756/resources/images----hellocmdline004.png" />
</figure>


Typing `ls` shows nothing!

The `ls` command means "list", which means to show the files and folders inside this folder. There is nothing in this folder, since we just made it. So, this is why typing `ls` shows nothing.

Now, let's change that by creating a file.

We are going to use a program called a text editor to edit the file. A text editor lets you type words in a file, and save the file just like you would save a game. We are just going to use a small text editor called `nano`. Nano means really small, and it's a good name since `nano` is a really small, simple text editor.

So, in Terminal, type `nano` and hit the Enter key.

 
<figure class="image block">
<img src="resources/2025-08-03T011754-113Z-042f7910-cac3-4014-bf5b-10cba15c17ca-20250803011756/resources/images----hellocmdline005.png" />
</figure>


This starts nano. The screen will look like this.

 
<figure class="image block">
<img src="resources/2025-08-03T011754-113Z-042f7910-cac3-4014-bf5b-10cba15c17ca-20250803011756/resources/images----hellocmdline006.png" />
</figure>


In nano, type `hello`. You don't need to hit the Enter key.

 
<figure class="image block">
<img src="resources/2025-08-03T011754-113Z-042f7910-cac3-4014-bf5b-10cba15c17ca-20250803011756/resources/images----hellocmdline007.png" />
</figure>


You can see that nano is being helpful, by showing you the list of commands you can type by holding down the `control` key and typing a letter. (Nano is showing the `control` key like the caret (`^`), but it is not `shift` + 6, it is the `control` key.)

 
<figure class="image block">
<img src="resources/2025-08-03T011754-113Z-042f7910-cac3-4014-bf5b-10cba15c17ca-20250803011756/resources/images----nano_commands.png" />
</figure>


So, to save the file, hold the `Control` key down and type the `o` key.

Nano will ask you what you want to call the file you are saving, by showing text saying "File Name to Write".

 
<figure class="image block">
<img src="resources/2025-08-03T011754-113Z-042f7910-cac3-4014-bf5b-10cba15c17ca-20250803011756/resources/images----hellocmdline008.png" />
</figure>


Type `hello.txt` and press the Enter key.

 
<figure class="image block">
<img src="resources/2025-08-03T011754-113Z-042f7910-cac3-4014-bf5b-10cba15c17ca-20250803011756/resources/images----hellocmdline009.png" />
</figure>


Nano will save the file and tell you it was one line long, by saying "Wrote 1 line".

 
<figure class="image block">
<img src="resources/2025-08-03T011754-113Z-042f7910-cac3-4014-bf5b-10cba15c17ca-20250803011756/resources/images----hellocmdline010.png" />
</figure>


(If you had hit Enter after typing "hello" earlier, it will say "Wrote 2 lines". That's fine, don't worry.)

Now that we've saved our file, let's quit nano by holding down the Control key and typing `x`. (A shorter way of saying this is to say "type `Control + x`". So, that's what I will say from now on.)

You will be back at the command line inside Terminal.

 
<figure class="image block">
<img src="resources/2025-08-03T011754-113Z-042f7910-cac3-4014-bf5b-10cba15c17ca-20250803011756/resources/images----hellocmdline011.png" />
</figure>


Let's look inside our `stuff` folder again. Remember last time we typed `ls` we saw it was empty. Type `ls` in Terminal again. You will see the hello.txt file you created.

 
<figure class="image block">
<img src="resources/2025-08-03T011754-113Z-042f7910-cac3-4014-bf5b-10cba15c17ca-20250803011756/resources/images----hellocmdline012.png" />
</figure>


Let's look inside this file. Type `cat hello.txt` in Terminal and hit Enter.

Here, `cat` is not an animal. Instead, it is a command that shows you what is in your file. Since we typed the word hello, this is what you will see.

 
<figure class="image block">
<img src="resources/2025-08-03T011754-113Z-042f7910-cac3-4014-bf5b-10cba15c17ca-20250803011756/resources/images----hellocmdline013.png" />
</figure>


So, the hello.txt file had "hello" inside it, so when you typed `cat hello.txt` you saw "hello".

You now know how to use some of the basic commands of the command line! You learned a bunch of strange commands, things like `mkdir`, `cd`, `ls` and `cat`. The neat thing is that these commands are actually just programs that were written by other people!

In the next lesson, you will create your first program, which you will also be able to run from the command line!

Finally, we are going to quit Terminal. Type `Command + Q` or choosing Quit Terminal from the Terminal menu.

 
<figure class="image block">
<img src="resources/2025-08-03T011754-113Z-042f7910-cac3-4014-bf5b-10cba15c17ca-20250803011756/resources/images----quittingterminal.png" />
</figure>


By the way, if you ever get something on the commmand line really wrong and you don't know what to do next, you can always just quit Terminal and open it up again.

Make sure you do the Exercises on the next page before continuing!

 page-break


## Exercises 

1.  Start Terminal and `cd` into the `stuff` directory.
2.  Use nano to make a file named `hooray.txt` that contains the text "hooray". Quit nano when you're done.
3.  Use the `cat` program to see the contents of your `hooray.txt` file.
4.  Quit Terminal.

You can see the [answers to the exercises](#chap14.xhtml#lesson1answers), or just continue to the quiz.

## Quiz 

 
[Take this quiz online](http://localhost:3001/courses/leanpub/programmingforkids/quizzes/quiz1)


</div>

[]{#chap02.xhtml}

<div>

# Lesson 2: Hello World! 

## Material 

Let's write our first computer program!

Start Terminal, `cd` into the `stuff` directory and run `nano`. (If that did not make sense, [read lesson 1 again](#chap02.xhtml#lesson1).)

We're going to create a really simple program. Type `puts "Hello World!"` in nano.

There's no need to hit the Enter key. I'll talk more about what `puts` means later.

To type a quote mark like `"`, hold the shift key and type the `'` key. There's no difference between the start and end quote marks.

 
<figure class="image block">
<img src="resources/2025-08-03T011754-113Z-042f7910-cac3-4014-bf5b-10cba15c17ca-20250803011756/resources/images----helloworld001.png" />
</figure>


That's it!

Type `Control + o` to save the file.

Nano will ask you what you want to call the file you are saving, by showing text saying "File Name to Write:"

Type `hello.rb` and press the `Enter` key. As you type the file name, you will see it shown in "File Name to Write" area near the bottom of Terminal.

 
<figure class="image block">
<img src="resources/2025-08-03T011754-113Z-042f7910-cac3-4014-bf5b-10cba15c17ca-20250803011756/resources/images----helloworld002.png" />
</figure>


Nano will save the file and tell you it was one line long, by saying "Wrote 1 line". (If you hit the Enter key, it will say Wrote 2 lines. That's fine too.)

Now that we've saved our file, type `Control + x` to quit nano.

Let's run our program!

In Terminal, type `ruby hello.rb` and hit `Enter`. You need a space between `ruby` and `hello.rb`.

 
<figure class="image block">
<img src="resources/2025-08-03T011754-113Z-042f7910-cac3-4014-bf5b-10cba15c17ca-20250803011756/resources/images----helloworld003.png" />
<figcaption>Your First Computer Program!</figcaption>
</figure>


Congratulations, you've written your first computer program! As you just saw, `puts` printed something to the screen.

But, what was that strange word "ruby"?

Ruby is a programming language. You speak English, but there are lots of other languages that people speak. Similarly, there are lots of different languages you can use to tell a computer what to do. Ruby is one of the easier ones to use, and your Mac comes with Ruby already installed.

The program you wrote was a Ruby program! The file extension (the stuff after the . in the filename) for Ruby programs is `rb`, so we named the file `hello.rb`.

In the next lesson, we will play with Ruby on its own command line!

## Exercises 

1\. Write and run a Ruby program named hi.rb that prints `Hi!`.

You can see the [answers to the exercises](#chap14.xhtml#lesson2answers), or just continue to the quiz.

## Quiz 

 
[Take this quiz online](http://localhost:3001/courses/leanpub/programmingforkids/quizzes/quiz2)


</div>

[]{#chap03.xhtml}

<div>

# Lesson 3: Hello, `irb`! 

## Material 

Ensure that Terminal is running, and that you are in the `stuff` directory. (If that did not make sense, see the [Lesson 1 Exercises](#chap01.xhtml#lesson1exercises).)

Ruby is a programming language. It also has its own command line called `irb`, which stands for Interactive Ruby Shell.

To start `irb`, just type `irb` in Terminal.

 
<figure class="image block">
<img src="resources/2025-08-03T011754-113Z-042f7910-cac3-4014-bf5b-10cba15c17ca-20250803011756/resources/images----helloirb001.png" />
</figure>


Note that irb has its own prompt. On my Mac, it looks like `irb(main):001:0> `. If you have an older version of Ruby on an older Mac, your irb prompt might just look like `>>`. The irb prompt just lets you know that irb is waiting for you to type a command. We'll ignore the other details that it shows.

Anyway, let's get irb to do your math homework!

Type `2 + 2` in irb and hit Enter. (You could have also just typed `2+2`, but I prefer to put spaces around the operators for readability.)

 
<figure class="image block">
<img src="resources/2025-08-03T011754-113Z-042f7910-cac3-4014-bf5b-10cba15c17ca-20250803011756/resources/images----helloirb002.png" />
</figure>


By the way, you should just use `irb` to check your answers when you do your math homework! This isn't just because you should learn math, it's because you should never just blindly trust the answer from a computer. You'll see why in a little bit.

To do multiplication, you use `*` (`shift` + `8`) not `x`.

Try `3 * 2` in irb.

<figure class="code" dir="ltr">
<div class="highlight">
<pre><code>irb&gt; 3 * 2
=&gt; 6</code></pre>
</div>
</figure>

To do division, you use `/` (which is beside the right `shift` key).

<figure class="code" dir="ltr">
<div class="highlight">
<pre><code>irb&gt; 6 / 2
=&gt; 3</code></pre>
</div>
</figure>

Now that you know how to divide in Ruby, what do you think the result of this is:

<figure class="code" dir="ltr">
<div class="highlight">
<pre><code>irb&gt; 5 / 2
=&gt;</code></pre>
</div>
</figure>

If you said `2.5` you'd be wrong!

<figure class="code" dir="ltr">
<div class="highlight">
<pre><code>irb&gt; 5 / 2
=&gt; 2</code></pre>
</div>
</figure>

The general lesson here is: don't blindly trust a computer.

The specific lesson is that there are different types of numbers in Ruby. There are floating point numbers (with decimals in them), and integers (with no decimals in them). The type of answer Ruby makes is based on the type of the numbers it is dividing.

If Ruby is dividing integers, it just does the division and throws away the remainder!

If either the numerator or denominator is a decimal, however, the result is a decimal:

<figure class="code" dir="ltr">
<div class="highlight">
<pre><code>irb&gt; 5.0/2
=&gt; 2.5</code></pre>
</div>
</figure>

By the way, if you are doing integer division (no decimals) in Ruby and you want the remainder, you can get it using something called the "mod" operator (for modulo), which is a `%` sign.

<figure class="code" dir="ltr">
<div class="highlight">
<pre><code>irb&gt; 5 % 2
=&gt; 1</code></pre>
</div>
</figure>

This is correct, since 5 divided by 2 is 2 and 1/2. The 1 here is the 1 which is over the 2.

To quit irb, type `quit`.

 
<figure class="image block">
<img src="resources/2025-08-03T011754-113Z-042f7910-cac3-4014-bf5b-10cba15c17ca-20250803011756/resources/images----quittingirb.png" />
</figure>


One of the reasons that Ruby is an easy programming language to learn is that it has irb, so you can experiment interactively really quickly.

In the next lesson, we're going to learn what functions are!

## Exercises 

1.  Have irb do `3 - 2`. The minus key, `-`, is beside the 0.
2.  Have irb do `3.0 / 2`. What do you think the answer is? Why?
3.  Have irb do `3 / 2`. What do you think the answer is? Why?

You can see the [answers to the exercises](#chap14.xhtml#lesson3answers), or just continue to the quiz.

## Quiz 

 
[Take this quiz online](http://localhost:3001/courses/leanpub/programmingforkids/quizzes/quiz3)


</div>

[]{#chap04.xhtml}

<div>

# Lesson 4: Functions 

## Material 

If all we could do with programming languages was basic math and say hello to ourselves, we wouldn't have anything more than a lousy calculator!

Let's do something more interesting!

We're going to define a function. Most computer programs are made up of a lot of functions. A function is something that does some stuff and returns a value. The return value is the answer.

Start irb again by typing `irb` in Terminal. (If Terminal isn't running, start it using Spotlight, and go into your stuff directory by typing `cd stuff`.)

Let's make a function that knows how to double any number.

Type this in irb, hitting Enter at the end of each line:

<figure class="code" dir="ltr">
<div class="highlight">
<pre><code>def double(x)
x+x
end</code></pre>
</div>
</figure>

To type `(` you hold shift and type 9, and to type `)` you hold shift and type 0.

 
<figure class="image block">
<img src="resources/2025-08-03T011754-113Z-042f7910-cac3-4014-bf5b-10cba15c17ca-20250803011756/resources/images----doublex.png" />
</figure>


This function is only 3 lines long, but there's lots going on here.

The word `def` is how we start defining a function in Ruby. (Programmers don't like to type long words, so `def` is short for define.)

The inputs to the function are put in brackets, which are the () things. In this example, we have one input. Since we don't like typing, we will name this input `x`.

The name of the function is called `double`.

One way to double a number is to add it to itself. To double 2, you say 2 + 2, which is 4. To double 3, you say 3 + 3, which is 6. What we are doing is making a function which can double any number. We don't know what that number is going to be in advance, so we just called it `x`. So, to double `x`, we just say `x+x`.

Finally, the last line is end, since that is how you end a function definition in Ruby.
When you typed this in, you saw that defining the function printed `=> nil`.

 
<figure class="image block">
<img src="resources/2025-08-03T011754-113Z-042f7910-cac3-4014-bf5b-10cba15c17ca-20250803011756/resources/images----doublex.png" />
</figure>


All this means is that return value of actually defining the function is nothing. In Ruby, we call nothing `nil`.

Anyway, we made a function that knows how to double a number, by adding it to itself. Let's see how it works.

I'm going to show the irb prompt as `irb>` from now on. This way, you will see what you type as input to irb (at the irb prompt) and what irb prints as output (with a `=>` arrow).

Anyway, type `double 2` in irb. When you follow along, you do not actually type `irb>`. Just type the stuff after it.

<figure class="code" dir="ltr">
<div class="highlight">
<pre><code>irb&gt; double 2
=&gt; 4</code></pre>
</div>
</figure>

2 + 2 is 4, so that looks right.

When you define a function you use `def` ... `end`. When you use the function that you defined, you are said to be calling the function To call a function, you just use the name of the function, and any arguments. So `double 2` is a function call. You can also put the arguments to the function in brackets, like this: `double(2)`.

Let's try a bigger number!

<figure class="code" dir="ltr">
<div class="highlight">
<pre><code>irb&gt; double 123
=&gt; 246</code></pre>
</div>
</figure>

123 + 123 is 246, so that looks right too!

Let's make another function. This one will triple numbers!

To triple something, you either add it to itself twice (2+2+2 is 6, and 6 is the triple of 2) or you multiply it by 3. The way you multiply something in Ruby (and in most programming languages) is with \*.

<figure class="code" dir="ltr">
<div class="highlight">
<pre><code>irb&gt; def triple(y)
irb&gt; y*3
irb&gt; end</code></pre>
</div>
</figure>

Note there is a space between `def` and `triple`.

Here, we're going to name the input to the function `y`, not `x`. This input is called a parameter.

It doesn't matter what you name the parameter, as long as you use the same name inside the function. So, you could have said this (don't actually type this):

<figure class="code" dir="ltr">
<div class="highlight">
<pre><code>irb&gt; def triple(dog)
irb&gt; dog*3
irb&gt; end</code></pre>
</div>
</figure>

Also, note that spaces don't usually matter. So, you could also have said this (don't actually type this either):

<figure class="code" dir="ltr">
<div class="highlight">
<pre><code>irb&gt; def triple(cat)
irb&gt; cat + cat + cat
irb&gt; end</code></pre>
</div>
</figure>

Anyway, let's test our new function! Type `triple 3` in irb, and hit Enter.

<figure class="code" dir="ltr">
<div class="highlight">
<pre><code>irb&gt; triple 3
=&gt; 9</code></pre>
</div>
</figure>

3 \* 3 is 9, which is the same thing as 3 + 3 + 3. So, this looks right!

Let's try a bigger number.

<figure class="code" dir="ltr">
<div class="highlight">
<pre><code>irb&gt; triple 10
=&gt; 30</code></pre>
</div>
</figure>

10 \* 3 is 30, which is the same thing as 10 + 10 + 10.

We've now made 2 functions! In the Exercises, we'll make 3 more! Leave irb open.

## Exercises 

1.  Write a function called quad to quadruple a number by mulitplying it by four. Test it afterward.
2.  Write a function called quad2 to quadruple a number by adding it to itself the correct number of times.
3.  Write a function called quad3 to quadruple a number by using the double function you made before.

You can see the [answers to the exercises](#chap14.xhtml#lesson4answers), or just continue to the quiz.

## Quiz 

 
[Take this quiz online](http://localhost:3001/courses/leanpub/programmingforkids/quizzes/quiz4)


</div>

[]{#chap05.xhtml}

<div>

# Lesson 5: Programs 

## Material 

If you haven't quit irb, quit it now. Then start irb again by typing `irb` in Terminal. (If Terminal isn't running, start it using Spotlight, and go into your stuff directory by typing `cd stuff`. Then run irb by typing `irb`.)

In the last lesson, we made two functions. The `double` function doubled a number, and the `triple` function tripled it.

Let's try running those again.

Type `double 2` in irb. Then try `triple 3`. Assuming you quit irb and restarted it, you will see something like this.

 
<figure class="image block">
<img src="resources/2025-08-03T011754-113Z-042f7910-cac3-4014-bf5b-10cba15c17ca-20250803011756/resources/images----wheredidfunctionsgo.png" />
<figcaption>Where Did Our Functions Go?</figcaption>
</figure>


The functions we made are gone!

The reason for this is that we didn't make them in a program file; we just made them in irb. So, when we quit irb, they were lost.

Luckily, this is easy enough to fix!

We already learned how to edit text files in nano. We will make a new program file which contains our `double` and `triple` functions. We will also make our program file test these functions!

Quit irb by typing `quit`. Then, open nano by typing `nano` in Terminal.

Type the following Ruby code into the file.

<figure class="code" dir="ltr">
<div class="highlight">
<pre><code>def double(x)
x*2
end

def triple(y)
y*3
end

puts double 2
puts triple 3</code></pre>
</div>
</figure>

Then, save the file by typing `Control + o`. Type `times.rb` and hit `Enter` to name the file `times.rb`.

 
<figure class="image block">
<img src="resources/2025-08-03T011754-113Z-042f7910-cac3-4014-bf5b-10cba15c17ca-20250803011756/resources/images----times.png" />
</figure>


Now that you've saved the file, quit nano by typing `Control + x`.

Let's run our program!

Type `ruby times.rb` in Terminal, and hit `Enter`. You will see something like this:

 
<figure class="image block">
<img src="resources/2025-08-03T011754-113Z-042f7910-cac3-4014-bf5b-10cba15c17ca-20250803011756/resources/images----times_output.png" />
</figure>


The first line shows the number `4`. This is the result of calling the `double` function with the number `2`, and printing the return value with `puts`.

The second line shows the number `9`. This is the result of calling the `triple` function with the number `3`, and printing the return value with `puts`.

What do you think would have happened if you hadn't said `puts` in the last 2 lines of your program?

We'll learn that in the next lesson...

## Exercises 

1\. Add a `quadruple` function to your program in your times.rb file. Also, test it afterward, in the times.rb file, by quadrupling 4. To open times.rb in nano, type `nano times.rb`.

You can see the [answers to the exercises](#chap14.xhtml#lesson5answers), or just continue to the quiz.

## Quiz 

 
[Take this quiz online](http://localhost:3001/courses/leanpub/programmingforkids/quizzes/quiz5)


</div>

[]{#chap06.xhtml}

<div>

# Lesson 6: Functions, Part 2 

## Material 

Way back in the first lesson about functions, I said that a function is something that does some stuff and returns a value. The return value is the answer.

Open a Terminal window, `cd` into the `stuff` directory, and open `irb`.

(By the way, you just understood that sentence. Think about how far you've come already!)

Let's look more closely at what it means to return a value.

First, we're going to load the times.rb program into irb. By doing this, we will import our functions from the times.rb program into the running irb, so that we can call those functions again!

The way we do this is by typing `load 'times.rb'` in irb. (Make sure to type the single quotes, which are beside the Enter key.) You will see something like this:

<figure class="code" dir="ltr">
<div class="highlight">
<pre><code>irb&gt; load &#39;times.rb&#39;
4
9
16
=&gt; true</code></pre>
</div>
</figure>

If you did not follow along with the last lesson exercises, you will just see:

<figure class="code" dir="ltr">
<div class="highlight">
<pre><code>irb&gt; load &#39;times.rb&#39;
4
9
=&gt; true</code></pre>
</div>
</figure>

If you do not see this, and instead see a `LoadError`, you either started irb from somewhere other than the `stuff` directory, or you didn't follow along with the last lesson or its exercises. If that happened, quit irb with `quit` and `cd` into your `stuff` directory. Make the `times.rb` file if necessary, then continue.

Anyway, now that you're here, I'm going to assume you've followed along!

When you load the `times.rb` file into `irb`, you see the same output that you saw when you ran the `times.rb` program on the command line using `ruby times.rb` in the last lesson.

This is because when you use the `load` command, you actually run the program!

You see 4 (which is the double of 2) and 9 (which is the triple of 3).

But what is that `=> true` thing?

That is the return value of running the program. When we do things in irb, it helpfully prints the return value.

So, for example, if you type `double 2` in irb, you see 4:

<figure class="code" dir="ltr">
<div class="highlight">
<pre><code>irb&gt; double 2
=&gt; 4</code></pre>
</div>
</figure>

Now, in the `times.rb` program we said `puts double 2` to print the double of 2. Let's try this in irb:

<figure class="code" dir="ltr">
<div class="highlight">
<pre><code>irb&gt; puts double 2
4
=&gt; nil</code></pre>
</div>
</figure>

So, here we see the same 4 that got printed when we ran `ruby times.rb` from the command line. But we also see `=> nil`. This is the return value of calling `puts double 2`.

This is the secret!

It turns out that `puts` is just a function!

The `puts` function is just like the `double` and `triple` functions you made earlier! The return value of `puts` is `nil`. So, when you call `puts` in irb, it prints `=> nil`. But when you call the `puts` function normally in a program, Ruby just prints what `puts` tells it to, and doesn't print the return value of `puts`. That's good, since `nil` is pretty boring!

So, let's do some fun stuff! You already know that typing `double 2` in irb returns 4.

<figure class="code" dir="ltr">
<div class="highlight">
<pre><code>irb&gt; double 2
=&gt; 4</code></pre>
</div>
</figure>

What do you think happens if you type `double double 2` in irb?

Well, irb is going to print the return value of all this. But what is it?

<figure class="code" dir="ltr">
<div class="highlight">
<pre><code>irb&gt; double double 2
=&gt; 8</code></pre>
</div>
</figure>

Is that a surprise?

Let's figure out how this works.

What do you think happens if you type `double 4` in irb?

<figure class="code" dir="ltr">
<div class="highlight">
<pre><code>irb&gt; double 4
=&gt; 8</code></pre>
</div>
</figure>

This makes sense, since 4 times 2 is 8.

But you know what?

2 times 2 is 4.

So, calling `double 2` is going to return 4.

And then, we are going to call `double` with this return value.

So, `double double 2` is the same thing as `double 4` which, as we saw, is 8.

Now, this can get confusing.

So, one thing you can do is put things in brackets, to make it clearer what is going on.

Try typing `double(double(2))` in irb.

To type `(` you type `shift + 9`, and to type `)` you type `shift + 0`.

<figure class="code" dir="ltr">
<div class="highlight">
<pre><code>irb&gt; double(double(2))
=&gt; 8</code></pre>
</div>
</figure>

So, we got 8 again. But the brackets show that we are first doing double(2), and then we are putting that return value into another call to double().

What do you think is returned if you do `triple(double(2))`?

<figure class="code" dir="ltr">
<div class="highlight">
<pre><code>irb&gt; triple(double(2))
=&gt; 12</code></pre>
</div>
</figure>

Do you see? 2 times 2 is 4, so `double(2)` will return 4. This 4 is then passed into the `triple` function. And 3 times 4 is 12. So, `triple(4)` will return 12.

That's exactly what happened!

But what do you think happens if you try typing `double(triple(2))`?

<figure class="code" dir="ltr">
<div class="highlight">
<pre><code>irb&gt; double(triple(2))
=&gt; 12</code></pre>
</div>
</figure>

It's also 12!

This is because 3 times 2 is 6, so triple(2) is 6. And 2 times 6 is 12, so double(6) is 12.

This is actually a rule about multiplication: the order does not matter. But you'll learn that in school in an older grade! (And, when you do, you can tell your teacher that you learned that from this course already!)

By the way, before we stop this lesson, I'm getting tired of writing times as "times". So, I'm going to start writing times as `*` instead of `times` or `x`. The word `times` is too annoying to type, and the letter `x` could get confused for a function parameter (like we saw before) or variable (like we will see).

We programmers are really lazy!

One more thing before we stop this lesson:

What do you think this returns?

`triple(double(triple(2)))`

If that's too many brackets, you can also type that as:

`triple double triple 2`

You don't need the brackets, since Ruby figures out the right thing to do here!

The way this works is as follows:

1.  Ruby figures out that `triple(2)` is 6, since 3\*2 = 6.
2.  Ruby figures out that `double(6)` is 12, since 2\*6 = 12. So, `double(triple(2))` is 12.
3.  Ruby figures out that `triple(12)` is 36, since 3\*12 = 36. So, `triple(double(triple(2)))` is 36.

If you look at these steps, this is the order of the function calls and return values:

<figure class="code" dir="ltr">
<div class="highlight">
<pre><code>triple(double(triple(2)))
triple(double(6))
triple(12)
36</code></pre>
</div>
</figure>

So, the return value is `36`.

Phew! That took a long time for us to do! Luckily, this is the type of thing that computers are really, really good at doing.

## Exercises 

Setup:

These exercises assume that you did the exercises from the last lesson where you made a `quadruple` function in the `times.rb` file. If you did not do that, do it now. If you had to quit irb, then when you restart it you need to remember to load the times.rb file by typing `load 'times.rb'` in irb.

1.  In irb, write and test a new `times6` function that uses a combination of the `double` and `triple` functions to return 6 times the number it was given.
2.  In irb, write and test a new `times12` function that uses a combination of the `double` and `triple` functions to return 12 times the number it was given.
3.  In irb, write and test a new `times12b` function that uses the new `times6` function and some other function to return 12 times the number it was given.
4.  Quit irb, then use nano to open the times.rb file with `nano times.rb`. Use nano to add `times6` and `times12` functions to your times.rb file. You can either just return `x*6` and `x*12`, or you can use whatever combination of the `double`, `triple`, `quadruple` and `times6` functions you want. Also, test your functions in the times.rb file by doing `6 * 6` (which is 36) and `12 * 12` (which is 144).

You can see the [answers to the exercises](#chap14.xhtml#lesson6answers), or just continue to the quiz.

## Quiz 

 
[Take this quiz online](http://localhost:3001/courses/leanpub/programmingforkids/quizzes/quiz6)


</div>

[]{#chap07.xhtml}

<div>

# Lesson 7: Characters and Strings 

## Material 

So far, we've done a lot of stuff with numbers. In this lesson, we will look at how to do stuff with words.

In Ruby, and in most programming languages, words are handled differently from numbers.

A word can be thought of as a sequence of letters. By sequence, I mean a bunch of letters in a row. For example, the word "word" is a sequence of 4 letters, w, o, r and d.

A number can be thought of as a sequence of digits. For example, the number 12 is a sequence of two digits, 1 and 2.

More generally, anything you can type on your keyboard, whether it is a letter, a number or other stuff like spaces, symbols like (!@#\$%\^&\*) or punctuation like ,.- can be thought of as a character.

So, a word or a number or a whole sentence is just a sequence of characters.

But, "sequence of characters" is annoying to type and say, so we just say string instead. If you think about beads, you can arrange them on a string to make a necklace. But in a computer, you can arrange characters in a string to make words, sentences and other stuff.

In this lesson, we're going to play with characters and strings.

Let's open up irb. (As always, if you are starting here, you start Terminal, type `cd stuff` to go into the `stuff` directory, and then type `irb` to start irb.)

First, let's just say "hello" in irb by typing the string `"hello"` in quotes.

<figure class="code" dir="ltr">
<div class="highlight">
<pre><code>irb&gt; &quot;hello&quot;
=&gt; &quot;hello&quot;</code></pre>
</div>
</figure>

As always, irb prints what the return value is. The return value of "hello" is "hello". So, saying "hello" returns "hello".

Let's do something more interesting. Type `"hello".length` in irb.

<figure class="code" dir="ltr">
<div class="highlight">
<pre><code>irb&gt; &quot;hello&quot;.length
=&gt; 5</code></pre>
</div>
</figure>

Cool! The length of "hello" is 5, since there are 5 letters in the word hello. Or, in programmer terms, there are 5 characters in the string "hello".

\*

Note that there are at least 2 ways to get the above example wrong.

If you forget the quotes, you'll see something like this:

<figure class="code" dir="ltr">
<div class="highlight">
<pre><code>irb(main):006:0&gt; hello.length
NameError: undefined local variable or
method `hello&#39; for main:Object
	from (irb):6
	from :0</code></pre>
</div>
</figure>

And, if you only do the first quote, irb will just sit there.

<figure class="code" dir="ltr">
<div class="highlight">
<pre><code>irb(main):007:0&gt; &quot;hello.length</code></pre>
</div>
</figure>

The reason is that irb is waiting for the string to be finished. So, to fix that, just type a " on a line by itself and hit Enter. Then, you will be back at the irb prompt and you can try the example again.

<figure class="code" dir="ltr">
<div class="highlight">
<pre><code>irb&gt; &quot;hello.length
irb&quot; &quot;
=&gt; &quot;hello.length\n&quot;
irb&gt; &quot;hello&quot;.length
=&gt; 5</code></pre>
</div>
</figure>

\*

If you are wondering, `length` is actually a function. In Ruby and in many programming languages, functions are organized in things called "objects". And in Ruby, a string is actually an object as well as a sequence of characters. We'll talk more about objects later.

Let's try another function!

<figure class="code" dir="ltr">
<div class="highlight">
<pre><code>irb&gt; &quot;hello&quot;.reverse
=&gt; &quot;olleh&quot;</code></pre>
</div>
</figure>

In Ruby, strings know how to reverse themselves. So, `olleh` is `hello` backwards.

What happens if we do this the other way?

<figure class="code" dir="ltr">
<div class="highlight">
<pre><code>irb&gt; &quot;olleh&quot;.reverse
=&gt; &quot;hello&quot;
irb&gt; &quot;hello&quot;.reverse.reverse
=&gt; &quot;hello&quot;</code></pre>
</div>
</figure>

Of course, this works with more than just words. Let's see how many characters are in this next sentence!

<figure class="code" dir="ltr">
<div class="highlight">
<pre><code>irb&gt; &quot;This is 4 words&quot;.length
=&gt; 15</code></pre>
</div>
</figure>

So, there are 15 characters in that sentence. Remember that the count of characters includes everything inside the quotes, including the spaces.

Finally, we can put things inside a string. This is known by the fancy word "interpolation", which basically means to stick stuff in the middle. So, let's say we want irb to tell us what 2+2 is, but in a nice sentence.

Type `"2 + 2 is #{2+2}."` in irb. To type the \# character, hold the `shift` key down and press `3`. To type the `{` character, hold the `shift` key down and type `[` (by the `Enter` key). To type the `}` character, hold the `shift` key down and type `]` (also by the `Enter` key).

<figure class="code" dir="ltr">
<div class="highlight">
<pre><code>irb&gt; &quot;2 + 2 is #{2+2}.&quot;
=&gt; &quot;2 + 2 is 4&quot;</code></pre>
</div>
</figure>

One more thing: remember the say command we used in lesson 1? That's actually a program.

And in Ruby, we can run programs by putting them in backticks. The backtick character

<figure class="code" dir="ltr">
<div class="highlight">
<pre><code>`</code></pre>
</div>
</figure>

is above the `Tab` key.

So, let's have `irb` use the `say` program to tell us what 2 + 2 is. Note that there is a backtick at the beginning and at the end of the irb command.

<figure class="code" dir="ltr">
<div class="highlight">
<pre><code>irb&gt; `say &quot;2 plus 2 is #{2+2}&quot;`
=&gt; &quot;&quot;</code></pre>
</div>
</figure>

By the way, note that the return value of calling `say` is nothing. So, instead of seeing `"2 plus 2 is 4"`, we see `""`. That is a string with nothing in it. We call a string with no characters in it an "empty string".

In the rest of the course, we'll do lots with strings. But for now, let's take a break! Quit irb by typing `quit`.

<figure class="code" dir="ltr">
<div class="highlight">
<pre><code>irb&gt; quit
~/stuff[]$</code></pre>
</div>
</figure>

## Exercises 

So far, the output of the `times.rb` program we have been building is pretty simple.

When we run it, we see the following:

<figure class="code" dir="ltr">
<div class="highlight">
<pre><code>~/stuff[]$ ruby times.rb
4
9
16
36
144
~/stuff[]$</code></pre>
</div>
</figure>

What do the numbers mean? We know, but anyone looking at it will not know.

It would be a lot nicer if we saw this:

<figure class="code" dir="ltr">
<div class="highlight">
<pre><code>~/stuff[]$ ruby times.rb
2 * 2 is 4
3 * 3 is 9
4 * 4 is 16
6 * 6 is 36
12 * 12 is 144
~/stuff[]$</code></pre>
</div>
</figure>

1.  Use nano to change the code in the times.rb file to show what is being multiplied. You do not need to modify the functions themselves, just the uses of the functions. (In other words, only change every line with a `puts` in it.) Remember to modify every line that has a `puts` function. Run the times.rb program with `ruby times.rb` to check.
2.  Use irb to find out what your name is backwards. Remember to start irb!

You can see the [answers to the exercises](#chap14.xhtml#lesson7answers), or just continue to the quiz.

## Quiz 

 
[Take this quiz online](http://localhost:3001/courses/leanpub/programmingforkids/quizzes/quiz7)


</div>

[]{#chap08.xhtml}

<div>

# Lesson 8: Variables 

## Material 

In the last lesson, we were writing stuff like `"hello".reverse` and `"olleh".reverse`. That was a bit annoying to type, wasn't it?

Let's fix this by making a variable. A variable is just a container for something. Think of it like a box or a bucket that can hold either a number, or a string, or anything you choose.

Start irb and try the following (remember the quotes!):

<figure class="code" dir="ltr">
<div class="highlight">
<pre><code>irb&gt; x = &quot;hello&quot;
=&gt; &quot;hello&quot;</code></pre>
</div>
</figure>

We start by creating a variable called `x` that holds the string "hello". If you imagine a box, we put the string `hello` in the box.

Let's check what's in the box. Remember that irb prints the value of what it evaluates. (Evaluate is a complicated idea, but basically it means to check the value. For a variable, the value is the contents of the variable. You might remember that earlier we saw that for a function call, the value is the return value from the function.)

So, let's just say `x` in irb:

<figure class="code" dir="ltr">
<div class="highlight">
<pre><code>irb&gt; x
=&gt; &quot;hello&quot;</code></pre>
</div>
</figure>

This prints hello, since x has the value "hello". This is the same thing that irb prints if we just type "hello":

<figure class="code" dir="ltr">
<div class="highlight">
<pre><code>irb&gt; &quot;hello&quot;
=&gt; &quot;hello&quot;</code></pre>
</div>
</figure>

So, x has the string "hello" in it. Let's see what happens when we call x's reverse function:

<figure class="code" dir="ltr">
<div class="highlight">
<pre><code>irb&gt; x.reverse
=&gt; &quot;olleh&quot;</code></pre>
</div>
</figure>

Why does x have a reverse function? Simple, it holds the string "hello", and strings have lots of functions, one of which is `reverse`.

Instead of just printing the value of `x.reverse`, let's store it in a new variable called `y`.

<figure class="code" dir="ltr">
<div class="highlight">
<pre><code>irb&gt; y = x.reverse
=&gt; &quot;olleh&quot;</code></pre>
</div>
</figure>

So, the result of `x.reverse` is "olleh", which is assigned to y. The value returned by the assignemnt is "olleh", so that's what irb prints.

Let's check that y really holds `olleh`, by asking irb to evaluate y:

<figure class="code" dir="ltr">
<div class="highlight">
<pre><code>irb&gt; y
=&gt; &quot;olleh&quot;</code></pre>
</div>
</figure>

What happens if we reverse y?

<figure class="code" dir="ltr">
<div class="highlight">
<pre><code>irb&gt; y.reverse
=&gt; &quot;hello&quot;</code></pre>
</div>
</figure>

Now, variables aren't just for holding strings. You can put anything in a variable. Let's put a number in a new variable called `i`:

<figure class="code" dir="ltr">
<div class="highlight">
<pre><code>irb&gt; i = 1
=&gt; 1
irb&gt; i
=&gt; 1</code></pre>
</div>
</figure>

So, `i` has the number 1 in it.

Let's make a new variable `j` that has the value of `i` plus 1:

<figure class="code" dir="ltr">
<div class="highlight">
<pre><code>irb&gt; j = i + 1
=&gt; 2
irb&gt; j
=&gt; 2</code></pre>
</div>
</figure>

So, at this point `x` is "hello", `y` is "olleh", `i` is 1 and `j` is 2.

What do you think happens if we try this:

<figure class="code" dir="ltr">
<div class="highlight">
<pre><code>irb&gt; i + j</code></pre>
</div>
</figure>

Well, 1 + 2 is 3, so you'd expect irb to say 3, right? That's what happens:

<figure class="code" dir="ltr">
<div class="highlight">
<pre><code>irb&gt; i + j
=&gt; 3</code></pre>
</div>
</figure>

Now, how about this:

<figure class="code" dir="ltr">
<div class="highlight">
<pre><code>irb&gt; x + y</code></pre>
</div>
</figure>

Well, x is "hello" and y is "olleh". What does it mean to add strings together?

In Ruby, it means to literally stick them together! This is called concatenating, which is pronounced "con cat n ate ing". Concatenating is just a fancy word for sticking stuff together.

Here's what you get:

<figure class="code" dir="ltr">
<div class="highlight">
<pre><code>irb&gt; x + y
=&gt; &quot;helloolleh&quot;</code></pre>
</div>
</figure>

Now, what if we try this?

<figure class="code" dir="ltr">
<div class="highlight">
<pre><code>irb&gt; x.length + i</code></pre>
</div>
</figure>

Well, x is the string "hello" which is of length 5, and i is 1, so you'd expect the result to be 6, right?

<figure class="code" dir="ltr">
<div class="highlight">
<pre><code>irb&gt; x.length + i
=&gt; 6</code></pre>
</div>
</figure>

How about let's do something silly and try x + i. What do you think happens when we try to add a string and a number?

<figure class="code" dir="ltr">
<div class="highlight">
<pre><code>irb(main):023:0&gt; x + i
TypeError: can&#39;t convert Fixnum into String
	from (irb):23:in `+&#39;
	from (irb):23
	from :0</code></pre>
</div>
</figure>

It doesn't work! Here, irb is complaining that you can't add a String and a Fixnum (what Ruby is calling the number 1) together, since they are different types of objects. We will learn more about objects in a few lessons.

## Exercises 

1.  Create a variable called `a` that has the value 4.
2.  Create a variable called `b` that has value of 5 times the value of `a`.
3.  Create a variable called `c` that has the value "hello world". (Remember the quotes!)
4.  Create a variable called `d` that has the value of the length of the string "hello world".

You can see the [answers to the exercises](#chap14.xhtml#lesson8answers), or just continue to the quiz.

## Quiz 

 
[Take this quiz online](http://localhost:3001/courses/leanpub/programmingforkids/quizzes/quiz8)


</div>

[]{#chap09.xhtml}

<div>

# Lesson 9: Command Line Input 

## Material 

In the last lesson, we learned about variables. However, without inputs, variables are pretty useless. We were doing stuff like `x = "hello"`, but that was just a way of saving a bit of typing. Our variables weren't varying much at all!

There are two ways that a command line program typically gets input:

1.  from the command line
2.  from a file

In this lesson, we're going to learn the command line approach.

The inputs we capture will go in variables, and then we'll be able to do fun stuff with them.

We will start by defining a function that reads a line of command line input and prints the reverse of it.

Start irb and type the following:

<figure class="code" dir="ltr">
<div class="highlight">
<pre><code>irb&gt; def reverse
irb&gt; s = gets
irb&gt; puts s.reverse
irb&gt; end
=&gt; nil</code></pre>
</div>
</figure>

The `gets` function reads a line of command line input and returns it. We store the result of `gets` in a variable called `s`. We then use `puts` to print the result of reversing `s`.

Let's try our function! Type `reverse` in irb.

<figure class="code" dir="ltr">
<div class="highlight">
<pre><code>irb&gt; reverse</code></pre>
</div>
</figure>

Note that irb will just sit there, waiting for a line of input.

Let's give it some input! Type `hello` and hit Enter.

<figure class="code" dir="ltr">
<div class="highlight">
<pre><code>irb&gt; reverse
hello</code></pre>
</div>
</figure>

You will see the following:

<figure class="code" dir="ltr">
<div class="highlight">
<pre><code>irb&gt; reverse
hello

olleh
=&gt; nil</code></pre>
</div>
</figure>

That was cool. But one thing we could improve is that our function is currently returning `nil`.

Functions should return meaningful results, not just print things.

Let's make the reverse function return the result of reversing the input it got. We will redefine the reverse function like this. You need to type this again to redefine the `reverse` function:

<figure class="code" dir="ltr">
<div class="highlight">
<pre><code>irb&gt; def reverse
irb&gt; s = gets
irb&gt; r = s.reverse
irb&gt; puts r
irb&gt; r
irb&gt; end
=&gt; nil</code></pre>
</div>
</figure>

Now, let's test our function again. Type reverse, and then type hello and Enter.

<figure class="code" dir="ltr">
<div class="highlight">
<pre><code>irb&gt; reverse
hello

olleh
=&gt; &quot;\nolleh&quot;</code></pre>
</div>
</figure>

So, we returned "olleh" as expected, but we have this strange `\n` thing at the front of it! What's that?

It is the newline character, which is what is produced on your Mac when you hit Enter. (On Windows computers, pressing Enter actually produces two characters, `\r` and `\n`. This kind of garbage can make programming annoying at times!)

We don't want the newline in our return value! To get rid of it, we will use the `strip` function that Ruby `String`s have. Redefine the reverse function again like this:

<figure class="code" dir="ltr">
<div class="highlight">
<pre><code>irb&gt; def reverse
irb&gt; s = gets
irb&gt; r = s.reverse.strip
irb&gt; puts r
irb&gt; r
irb&gt; end
=&gt; nil</code></pre>
</div>
</figure>

Here we are calling `strip` on the result of `s.reverse`. We are then assigning the return value to r. This type of thing where we call a function on the result of another function is called chaining, and it's why we want our functions to always return meaningful values.

Let's test our new and improved reverse function!

<figure class="code" dir="ltr">
<div class="highlight">
<pre><code>irb&gt; reverse
hello
olleh
=&gt; &quot;olleh&quot;</code></pre>
</div>
</figure>

Now we have the return value of "olleh" as we wanted, without the `\n` newline that we stripped.

Let's try something a bit more interesting. We will build a function that adds 2 numbers that the user specifies on the command line. (To type the underscore character `_` hold down the `shift` key and type the minus key which is beside the 0.)

<figure class="code" dir="ltr">
<div class="highlight">
<pre><code>irb&gt; def add2
irb&gt; puts &quot;First&quot;
irb&gt; m = gets.strip.to_i
irb&gt; puts &quot;Second&quot;
irb&gt; n = gets.strip.to_i
irb&gt; m + n
irb&gt; end
=&gt; nil</code></pre>
</div>
</figure>

Let's try this out!

<figure class="code" dir="ltr">
<div class="highlight">
<pre><code>irb&gt; add2
First
2
Second
3
=&gt; 5</code></pre>
</div>
</figure>

2 + 3 is 5, so our add2 function worked!

One little detail I glossed over is that to get each number, we are chaining `gets.strip.to_i`.

Here's how this chaining works. Say the user types 2 and hits Enter:

1.  To get a line of command line input, we use `gets`. The value of the string is `2\n`. The `gets` function always gets a string. That's what the s in gets is for!
2.  To remove the newline (`\n`), we feed the output of gets into strip. The value of the string is now `2`.
3.  To turn the string into an integer (a whole number with no remainder or fractional part), we use `to_i`. This converts the `2` string into the number 2.

Note that some text or a number in quotes is a string, whereas a number not in quotes is a number. So, "2" is a string, and 2 is a number.

## Exercises 

### Question 1 

Write a function called `hi` that asks for the user's name by saying "name?", gets it from the command line and returns "Hello " plus the string. Do not include the newline that you get from the input. Test your function with your name! (For me, the function says "Hello Peter".) It doesn't matter what you call your variable, but if you want to match the answer, call it `n`.

Here's what you type in irb. Well, you need to fill in the body of the `hi` function with your code, of course!

<figure class="code" dir="ltr">
<div class="highlight">
<pre><code>irb&gt; def hi
irb&gt; # write your code here
irb&gt; end
=&gt; nil
irb&gt; hi
name?
Peter
=&gt; &quot;Hello Peter&quot;</code></pre>
</div>
</figure>

### Question 2 

Write a function called `cat` that asks for two strings on the commmand line and returns the concatenated string together. (Concatenating means to stick the two strings together, and is done with `+`. If you forget how to do this, take a peek back at the previous lesson!) To ask for each string, just print the text "input?". Do not include the newlines. Test your function with the strings "one" and "two". The result should be "onetwo". It doesn't matter what you call your variables, but if you want to match the answer, call them `a` and `b`.

Here's what you type in irb. Well, you need to fill in the body of the `cat` function with your code, of course!

<figure class="code" dir="ltr">
<div class="highlight">
<pre><code>irb&gt; def cat
irb&gt; # write your code here
irb&gt; end
=&gt; nil
irb&gt; cat
input?
one
input?
two
=&gt; &quot;onetwo&quot;</code></pre>
</div>
</figure>

You can see the [answers to the exercises](#chap14.xhtml#lesson9answers), or just continue to the quiz.

## Quiz 

 
[Take this quiz online](http://localhost:3001/courses/leanpub/programmingforkids/quizzes/quiz9)


</div>

[]{#chap10.xhtml}

<div>

# Lesson 10: Arrays and Looping 

## Material 

So far in this course, we've been working with single things. We've played with strings like `"hello"`, or variables like x that hold numbers like `2` or strings like, well, `"hello"`.

But one of the things computers are really good at is dealing with a bunch of stuff. Say, millions of strings, like all the names in a phone book. (If you've never seen a phone book: Once upon a time, phones were things that were mounted on walls. To dial a number you turned a dial which had holes for your fingers. These phones didn't even have cameras or any apps! There was no Google back then, so to find a phone number you looked it up in a book of phone numbers called a "phone book".)

In this lesson, we're going to learn how to work with arrays, which can hold anything from a list of numbers to all the entries in a phone book.

Start irb.

We will start by making a new array called `a`, and filling it with some numbers.

To type the square brackets `[` and `]` you hit the keys to the right of the `p` key.

<figure class="code" dir="ltr">
<div class="highlight">
<pre><code>irb&gt; a = [5,2,4,1,3]
=&gt; [5, 2, 4, 1, 3]
irb&gt; a
=&gt; [5, 2, 4, 1, 3]</code></pre>
</div>
</figure>

Every different thing in the array is called an element of the array. This array `a` has 5 elements.

Arrays in Ruby are objects, and they come with some handy built-in functions.

For example, there is the `sort` function, which returns a new array which has the same elements, but sorted.

Let's try this by typing `a.sort`.

<figure class="code" dir="ltr">
<div class="highlight">
<pre><code>irb&gt; a.sort
=&gt; [1, 2, 3, 4, 5]</code></pre>
</div>
</figure>

Now, this does not actually change the array a itself! To see that, just type `a` and Enter again. It is unchanged from when we created it.

<figure class="code" dir="ltr">
<div class="highlight">
<pre><code>irb&gt; a
=&gt; [5, 2, 4, 1, 3]</code></pre>
</div>
</figure>

If we want to modify the `a` array, we can use a function called `sort!` (yes, the exclamation mark ! is part of the name). Type `a.sort!` in irb:

<figure class="code" dir="ltr">
<div class="highlight">
<pre><code>irb&gt; a.sort!
=&gt; [1, 2, 3, 4, 5]</code></pre>
</div>
</figure>

The return value here is the sorted array, just like before. Now type `a` and Enter again, however:

<figure class="code" dir="ltr">
<div class="highlight">
<pre><code>irb&gt; a
=&gt; [1, 2, 3, 4, 5]</code></pre>
</div>
</figure>

This time the array `a` is sorted.

In Ruby, functions which modify the thing they operate on are often named with an exclamation mark `!` at the end of the name. Normal functions which just return a new value but leave the thing they operate on unchanged do not have an exclamation mark at the end of the name. By the way, since we programmers are lazy, we often say "bang" instead of "exclamation mark". So, the `sort!` function would be called "sort bang", instead of the normal "sort" function.

So, now we have a nicely sorted array. One thing that is useful to do with arrays is to "loop" over them, processing each element one at a time.

In most programming languages, the way you do this is with a `for` loop or a `while` loop, and we will look at those approaches later. But in Ruby, there are some easy built-in ways to loop over things. These are called blocks. The easiest way to learn blocks is to type an example. To type the `|` character (called a "pipe"), hold the `shift` key and type `\` (above the Enter key):

<figure class="code" dir="ltr">
<div class="highlight">
<pre><code>irb&gt; a.each do |item|
irb&gt; puts item
irb&gt; end
1
2
3
4
5
=&gt; [1, 2, 3, 4, 5]</code></pre>
</div>
</figure>

Here, we are processing each element of the array `a`, one at a time. The element we are processing is loaded into the `item`. Just like functions have parameters, blocks have parameters too. The block parameter is like a variable, which is set to the given element we are processing. When we are done, the entire array is returned.

You can also do this on one line with curly braces `` at the same time!)

<figure class="code" dir="ltr">
<div class="highlight">
<pre><code>irb&gt; a.each {|item| puts item}
1
2
3
4
5
=&gt; [1, 2, 3, 4, 5]</code></pre>
</div>
</figure>

Also, there's nothing special about the name `item`, it's just the name we chose for our block parameter. We could have called it anything:

<figure class="code" dir="ltr">
<div class="highlight">
<pre><code>irb&gt; a.each {|i| puts i}
1
2
3
4
5
=&gt; [1, 2, 3, 4, 5]</code></pre>
</div>
</figure>

Arrays don't just hold numbers, they can hold anything. Let's make a new array called `b` that holds some strings.

<figure class="code" dir="ltr">
<div class="highlight">
<pre><code>irb&gt; b = [&quot;cake&quot;, &quot;is&quot;, &quot;tasty&quot;]
=&gt; [&quot;cake&quot;, &quot;is&quot;, &quot;tasty&quot;]</code></pre>
</div>
</figure>

If we type `b` and Enter, we see it has the three strings in it:

<figure class="code" dir="ltr">
<div class="highlight">
<pre><code>irb&gt; b
=&gt; [&quot;cake&quot;, &quot;is&quot;, &quot;tasty&quot;]</code></pre>
</div>
</figure>

Now let's loop over the array, and reverse each of the strings:

<figure class="code" dir="ltr">
<div class="highlight">
<pre><code>irb&gt; b.each do |item|
irb&gt; puts item.reverse
irb&gt; end
ekac
si
ytsat
=&gt; [&quot;cake&quot;, &quot;is&quot;, &quot;tasty&quot;]</code></pre>
</div>
</figure>

Doing this did not modify the original array though. We can check that by typing `b` and Enter again:

<figure class="code" dir="ltr">
<div class="highlight">
<pre><code>irb&gt; b
=&gt; [&quot;cake&quot;, &quot;is&quot;, &quot;tasty&quot;]</code></pre>
</div>
</figure>

In these examples of using `each`, we have been just returning the original array.

What if we want to actually return something different?

To do this, we use another function that comes with Ruby arrays, called `map`.

What `map` does is build a new array, which contains the result of doing something to each element of the original array.

Let's see some examples!

Our `a` array looks like this:

<figure class="code" dir="ltr">
<div class="highlight">
<pre><code>irb&gt; a
=&gt; [1, 2, 3, 4, 5]</code></pre>
</div>
</figure>

Let's use map to get a new array, with every element 1 bigger than before:

<figure class="code" dir="ltr">
<div class="highlight">
<pre><code>irb&gt; a.map {|i| i+1}
=&gt; [2, 3, 4, 5, 6]</code></pre>
</div>
</figure>

Our `b` array looks like this:

<figure class="code" dir="ltr">
<div class="highlight">
<pre><code>irb&gt; b
=&gt; [&quot;cake&quot;, &quot;is&quot;, &quot;tasty&quot;]</code></pre>
</div>
</figure>

Let's use map to get a new array, with every element reversed:

<figure class="code" dir="ltr">
<div class="highlight">
<pre><code>irb&gt; b.map {|item| item.reverse}
=&gt; [&quot;ekac&quot;, &quot;si&quot;, &quot;ytsat&quot;]</code></pre>
</div>
</figure>

In both cases, `a` and `b` are unchanged by calling `map`:

<figure class="code" dir="ltr">
<div class="highlight">
<pre><code>irb&gt; a
=&gt; [1, 2, 3, 4, 5]
irb&gt; b
=&gt; [&quot;cake&quot;, &quot;is&quot;, &quot;tasty&quot;]</code></pre>
</div>
</figure>

What if we want to modify them? Guess what? In Ruby, arrays come with a method that does that too! It's called `map!`, since it's a `map` that changes its input, just like how `sort!` was a `sort` that changed its input.

Please follow along with these exactly, since the exercises below assume you did.

Let's add 1 to every element of `a`:

<figure class="code" dir="ltr">
<div class="highlight">
<pre><code>irb&gt; a.map! {|i| i+1}
=&gt; [2, 3, 4, 5, 6]
irb&gt; a
=&gt; [2, 3, 4, 5, 6]</code></pre>
</div>
</figure>

Let's reverse all the strings in `b`:

<figure class="code" dir="ltr">
<div class="highlight">
<pre><code>irb&gt; b.map! {|item| item.reverse}
=&gt; [&quot;ekac&quot;, &quot;si&quot;, &quot;ytsat&quot;]
irb&gt; b
=&gt; [&quot;ekac&quot;, &quot;si&quot;, &quot;ytsat&quot;]</code></pre>
</div>
</figure>

## Exercises 

1.  Use `map!` to put `a` back to being \[1,2,3,4,5\]. Verify that `a` is changed afterward by typing `a` and Enter.
2.  Use `map!` to put `b` back to being \["cake", "is", "tasty"\]. Verify that `b` is changed afterward by typing `b` and Enter.
3.  Use `each` and `puts` to print all the elements in `b`. Use the curly brace `{` and `}` style here.
4.  Use `each` to print 3 plus all the elements in `a`. Use the `do` ... `end` style here.
5.  If you multiply a number by itself you are "squaring" the number. Use `each` and `puts` to print the result of multiplying all the numbers in `a` by themselves.

By the way, did you notice that in question 2 you had already typed it exactly? The `reverse` function works both ways! (My son thought this was a good joke when I showed him :) In irb you can just type the up arrow to get access to your previous typing. So if you just hit the up arrow a few times you could get back to `b.map! {|item| item.reverse}` and not have to type it again!

You can see the [answers to the exercises](#chap14.xhtml#lesson10answers), or just continue to the quiz.

## Quiz 

 
[Take this quiz online](http://localhost:3001/courses/leanpub/programmingforkids/quizzes/quiz10)


</div>

[]{#chap11.xhtml}

<div>

# Lesson 11: Files 

## Material 

Back in lesson 9 we learned how to get input from the command line. In this lesson, we will learn how to get input from files!

First, we need to create a file to get some input from.

Start Terminal and `cd` into the stuff directory by tying `cd stuff` and pressing the Enter key. If you are still in irb from the last lesson, you need to quit irb first by typing `quit` and pressing the Enter key.

Start nano by typing `nano` and pressing the Enter key in Terminal.

We are going to create a file with a list of words, one per line. Type the following in nano, making sure to put an extra blank line at the end of the file (after you type `pear`, hit Enter twice):

<figure class="code" dir="ltr">
<div class="highlight">
<pre><code>apple
banana
peach
pear</code></pre>
</div>
</figure>

To save the file, hold down the `control` key and type the `o` key. Nano will ask you for a filename. Type `words.txt` and press the Enter key. Then quit nano by holding down the `control` key and type the `x` key.

Let's check that we created the file correctly by using the `cat` program to print the file:

<figure class="code" dir="ltr">
<div class="highlight">
<pre><code>~/stuff[]$ cat words.txt
apple
banana
peach
pear

~/stuff[]$</code></pre>
</div>
</figure>

If you didn't get this, or if this did not make any sense, you should quickly re-read lesson 1 to refresh your memory about how to use nano!

Start irb.

Let's play with this file!

We are going to start by opening up the file, reading every line and printing it. This sounds complicated, right? Well, in Ruby, it's easy: it's just a small loop, using a block. Type these 3 lines. Note that when you type `File` the `F` is a capital `F`. Also, there is a period (`.`) between `File` and `foreach`:

<figure class="code" dir="ltr">
<div class="highlight">
<pre><code>irb&gt; File.foreach(&quot;words.txt&quot;) do |line|
irb&gt; puts line
irb&gt; end
apple
banana
peach
pear

=&gt; nil
irb&gt;</code></pre>
</div>
</figure>

That was easy!

By the way, you can also use curly braces (`{` and `}`) to do this on one line:

<figure class="code" dir="ltr">
<div class="highlight">
<pre><code>irb&gt; File.foreach(&quot;words.txt&quot;) { |line| puts line }
apple
banana
peach
pear

=&gt; nil
irb&gt;</code></pre>
</div>
</figure>

But, what if we want to actually keep the contents of the file around to do other stuff with it? After our block is done, the lines are gone!

Let's read the file a different way:

<figure class="code" dir="ltr">
<div class="highlight">
<pre><code>irb&gt; lines = File.readlines &quot;words.txt&quot;
=&gt; [&quot;apple\n&quot;, &quot;banana\n&quot;, &quot;peach\n&quot;,
&quot;pear\n&quot;, &quot;\n&quot;]</code></pre>
</div>
</figure>

We used the `readlines` function of `File` to read all the lines of the file at once, into an array! We stored this array of lines in a variable called `lines`.

But we have those `\n` characters again! We don't want those!

Let's get rid of them, using the `map!` function.

<figure class="code" dir="ltr">
<div class="highlight">
<pre><code>irb&gt; lines.map! {|line| line.strip}
=&gt; [&quot;apple&quot;, &quot;banana&quot;, &quot;peach&quot;, &quot;pear&quot;, &quot;&quot;]</code></pre>
</div>
</figure>

At this point, the lines variable is an array with each line without the newlines.

But, we have an empty string in the last element of the lines array. We don't want that either! Let's get rid of it, using the `reject!` function.

<figure class="code" dir="ltr">
<div class="highlight">
<pre><code>irb&gt; lines.reject! {|line| line.empty?}
=&gt; [&quot;apple&quot;, &quot;banana&quot;, &quot;peach&quot;, &quot;pear&quot;]</code></pre>
</div>
</figure>

That's better!

The `reject!` function works by throwing away every element which matches the test inside the block. For us, the test was `line.empty?`. So, this is how we used `reject!` to get rid of all the blank lines. (There is both a `reject` and a `reject!` version: `reject` does not modify the original array, while `reject!` does. This is just like the `map` and `map!` or `sort` and `sort!` functions.)

By the way, you may be wondering why I made sure you added a blank line in nano, just to go to the work of `reject`ing it here. The reason is simple: part of programming is dealing with inputs that might not be exactly how you want them. So, you need to make sure that everything is fine before proceeding, instead of just charging ahead hopefully.

Anyway, let's now print the lines. For variety, we'll use `do` ... `end` not ``. (In practice, the usual style is to use `` for one line loops, and `do` ... `end` for multiple line loops.)

<figure class="code" dir="ltr">
<div class="highlight">
<pre><code>irb&gt; lines.each do |line|
irb&gt; puts line
irb&gt; end
apple
banana
peach
pear
=&gt; [&quot;apple&quot;, &quot;banana&quot;, &quot;peach&quot;, &quot;pear&quot;]</code></pre>
</div>
</figure>

Before we stop this lesson, let's actually write a program!

We've been spending a lot of lessons just playing in irb. While this is fun, it's not permanent. When we quit irb, we lose the work we've done!

We are going to write a program called `doge`. What it will do is print all the lines of a file, like `cat` does. But, it will also say the lines. Also, at the start of the program it will print and say "wow", and at the end of the program it will print and say "so amaze". (No, this is not good grammar! But memes on the internet don't have good grammar usually...)

Quit irb, then start nano.

You're going to write the longest program you've ever written!

Let's start by defining a function called `putsay`.

This function will use `puts` to print whatever string it is given as a parameter. We will call the parameter `str`, for string.

It will then use the `say` command to say the string. We use the backticks to run the say command. To type a backtick, press the key to the left of the 1. Make sure you type both backticks, the one before `say` and the one after `#{str}`. To type a #, hold the `shift` key and type 3. Also, note that you are in nano, so if you make a mistake, don't worry, just fix it!

<figure class="code" dir="ltr">
<div class="highlight">
<pre><code>def putsay(str)
  puts str
  `say #{str}`
end</code></pre>
</div>
</figure>

After the `end` statement, hit Enter twice. This adds a newline and a blank line. You need the newline after the `end`. The second newline is just so our program looks nice.)

Then, add the following code. Again, the `File` needs a capital `F`, and there is a period (`.`) between `File` and `readlines`. Also, make sure you add the quotes before and after `words.txt`:

<figure class="code" dir="ltr">
<div class="highlight">
<pre><code>lines = File.readlines &quot;words.txt&quot;
lines.map! {|line| line.strip}
lines.reject! {|line| line.empty?}
putsay &quot;wow&quot;
lines.each do |line|
  putsay line
end
putsay &quot;so amaze&quot;</code></pre>
</div>
</figure>

Here's what this code does:

1.  We read all the lines in the `words.txt` file into an array, which is stored in a variable called `lines`.
2.  We then get rid of the newlines using `map`.
3.  We then get rid of the blank lines using `reject`.
4.  We use `putsay` to print and say "wow".
5.  We then loop over all the lines in the `lines` array using a block. For each line, we call the `putsay` function we defined.
6.  Finally, we use putsay to print and say "so amaze".

Before you save the file, make sure it looks like this:

<figure class="code" dir="ltr">
<div class="highlight">
<pre><code>def putsay(str)
  puts str
  `say #{str}`
end

lines = File.readlines &quot;words.txt&quot;
lines.map! {|line| line.strip}
lines.reject! {|line| line.empty?}
putsay &quot;wow&quot;
lines.each do |line|
  putsay line
end
putsay &quot;so amaze&quot;</code></pre>
</div>
</figure>

To save the file, hold down the `control` key and type the `o` key. Nano will ask you for a filename. Type `doge.rb` and press the Enter key.

Then quit nano by holding down the `control` key and type the `x` key.

Run your new program by typing `ruby doge.rb` and hit Enter.

You will see the following:

<figure class="code" dir="ltr">
<div class="highlight">
<pre><code>~/stuff[]$ ruby doge.rb
wow
apple
banana
peach
pear
so amaze</code></pre>
</div>
</figure>

(Ignore the `~/stuff[]$`, that is just what my prompt looks like.)

Also, if you had your sound on, you should have heard your program!

Great job! This was the most complex program you've ever written...

## Exercises 

1.  Make the `doge` program reverse the order of the words in the array. (Arrays have a `reverse!` and a `reverse` function.)
2.  Arrays also have `shuffle` and `shuffle!` functions. These functions take no arguments and randomize the order of the elements of the array. (The `shuffle!` version modifies the original array, while the `shuffle` version does not.) Use one of those functions to make the `doge` program print the words in the array in a random order. Test this a few times to convince yourself that the order is indeed changing.

You can see the [answers to the exercises](#chap14.xhtml#lesson11answers), or just continue to the quiz.

## Quiz 

 
[Take this quiz online](http://localhost:3001/courses/leanpub/programmingforkids/quizzes/quiz11)


</div>

[]{#chap12.xhtml}

<div>

# Lesson 12: Booleans, If and While 

## Material 

Programs are built out of functions, and out of series of statements. But there is one other really important thing that programs are built on:

Making decisions.

If we can teach our program to make decisions based on the truth or falseness of expressions and variables, then we can solve a lot of problems! This includes deciding what to do using an `if` statement, and deciding whether to loop using a `while` loop.

Anyway, we have some learning to do. Start irb.

In programming languages, truth is precisely defined. (In human languages, it's trickier!)

In Ruby, `true` is true and `false` is false:

<figure class="code" dir="ltr">
<div class="highlight">
<pre><code>irb&gt; true
=&gt; true
irb&gt; false
=&gt; false</code></pre>
</div>
</figure>

You can also negate `true` and `false`. In this sense, "negate" means to make `true` `false`, and `false` `true`. The way you do this is with the `not` operator.

<figure class="code" dir="ltr">
<div class="highlight">
<pre><code>irb&gt; not true
=&gt; false
irb&gt; not false
=&gt; true</code></pre>
</div>
</figure>

Now, in most programming languages, it is preferable to write not as `!` instead of as `not`. Ruby is no exception here:

<figure class="code" dir="ltr">
<div class="highlight">
<pre><code>irb&gt; !true
=&gt; false
irb&gt; !false
=&gt; true</code></pre>
</div>
</figure>

You can assign `true` and `false` directly to variables.

<figure class="code" dir="ltr">
<div class="highlight">
<pre><code>irb&gt; t = true
=&gt; true
irb&gt; t
=&gt; true
irb&gt; f = false
=&gt; false
irb&gt; f
=&gt; false</code></pre>
</div>
</figure>

You can even negate these variables too.

<figure class="code" dir="ltr">
<div class="highlight">
<pre><code>irb&gt; !t
=&gt; false
irb&gt; !f
=&gt; true</code></pre>
</div>
</figure>

In programming languages like Ruby, true and false is not only precisely defined, it is also produced as a result of boolean expressions. Boolean expressions are just expressions that produce either `true` or `false`.

(Different programming languages have their own quirks here, and Ruby is no different, so I'm glossing over some details.)

To check if something is the same we use the equality operator, which is two equals signs `==`in a row.

<figure class="code" dir="ltr">
<div class="highlight">
<pre><code>irb&gt; 2 == 2
=&gt; true
irb&gt; 2 == 3
=&gt; false</code></pre>
</div>
</figure>

2 is equal to 2, so the first expression returns true. And 2 is not equal to 3, so the second expression returns false.

You can use the equality operator to test more than just numbers. For example, it can test strings. (Don't forget the quotes here! If you do not put quotes around the letters `a` and `b`, Ruby will get confused and think you are referring to some variables `a` and `b` that it does not know anything about.)

<figure class="code" dir="ltr">
<div class="highlight">
<pre><code>irb&gt; &quot;a&quot; == &quot;a&quot;
=&gt; true
irb&gt; &quot;a&quot; == &quot;b&quot;
=&gt; false</code></pre>
</div>
</figure>

There's also an inequality operator. It is written as `!=` and it checks if two things are not equal:

<figure class="code" dir="ltr">
<div class="highlight">
<pre><code>irb&gt; 2 != 2
=&gt; false
irb&gt; 2 != 3
=&gt; true
irb&gt; &quot;a&quot; != &quot;a&quot;
=&gt; false
irb&gt; &quot;a&quot; != &quot;b&quot;
=&gt; true</code></pre>
</div>
</figure>

Now that we know how to test values using equality and inequality operators, we can use these operators to test the values of variables.

So, let's make a variable and assign a value to it, and then test that value.

<figure class="code" dir="ltr">
<div class="highlight">
<pre><code>irb&gt; x = 2
=&gt; 2
irb&gt; x
=&gt; 2
irb&gt; x == 2
=&gt; true
irb&gt; x == 3
=&gt; false
irb&gt; x != 2
=&gt; false
irb&gt; x != 3
=&gt; true</code></pre>
</div>
</figure>

This doesn't just work for numbers. Let's try it with strings.

<figure class="code" dir="ltr">
<div class="highlight">
<pre><code>irb&gt; y = &quot;hi&quot;
=&gt; &quot;hi&quot;
irb&gt; y
=&gt; &quot;hi&quot;
irb&gt; y == &quot;hi&quot;
=&gt; true
irb&gt; y != &quot;hi&quot;
=&gt; false</code></pre>
</div>
</figure>

Finally, you can work with the result of a boolean `==` or `!=` test. Let's test if x is equal to 2, and assign the result of that test to the variable `u`. We put `x == 2` in brackets to be clear about what happens first.

<figure class="code" dir="ltr">
<div class="highlight">
<pre><code>irb&gt; x
=&gt; 2
irb&gt; x == 2
=&gt; true
irb&gt; u = (x == 2)
=&gt; true
irb&gt; u
=&gt; true</code></pre>
</div>
</figure>

You know the saying "two wrongs don't make a right"? Well, in programming, negating a negation makes it true.

<figure class="code" dir="ltr">
<div class="highlight">
<pre><code>irb&gt; true
=&gt; true
irb&gt; !true
=&gt; false
irb&gt; !!true
=&gt; true</code></pre>
</div>
</figure>

Oh, by the way, this works for variables too.

<figure class="code" dir="ltr">
<div class="highlight">
<pre><code>irb&gt; u
=&gt; true
irb&gt; !u
=&gt; false
irb&gt; !!u
=&gt; true</code></pre>
</div>
</figure>

Besides the equality `==` and inequality `!=` operators, there are other operators that produce `true` and `false` values too.

Some of the most common ones are ones that compare two things.

- The less than operator `<` checks if one thing is less than another thing.
- The less than or equal to operator `<=` checks if one thing is smaller than or the same as another thing.
- The greater than operator `>` checks if one thing is bigger than another thing.
- The greater than or equal to operator `>=` checks if one thing is bigger than or the same as another thing.

Note that I said "thing" here, not "number". This is because you can compare some things that aren't numbers using these operators. However, usually you just compare numbers!

By the way, if you need help remembering which is less than and which is greater than, less than `<` looks like an L that is leaning forward.

<figure class="code" dir="ltr">
<div class="highlight">
<pre><code>irb&gt; 1 &lt; 2
=&gt; true
irb&gt; 1 &lt;= 2
=&gt; true
irb&gt; 2 &lt; 2
=&gt; false
irb&gt; 2 &lt;= 2
=&gt; true
irb&gt; 3 &gt; 2
=&gt; true
irb&gt; 3 &gt;= 2
=&gt; true
irb&gt; 2 &gt; 2
=&gt; false
irb&gt; 2 &gt;= 2
=&gt; true</code></pre>
</div>
</figure>

Now, this is a bit silly since you know what these expressions all are. You know that 1 is less than 2; you don't need Ruby to tell you!

The real use here is in comparing a variable to a number.

<figure class="code" dir="ltr">
<div class="highlight">
<pre><code>irb&gt; n = 5
=&gt; 5
irb&gt; n
=&gt; 5
irb&gt; n &lt; 6
=&gt; true
irb&gt; n &lt; 5
=&gt; false</code></pre>
</div>
</figure>

Now, this is also contrived, since we know what n is. But when you realize that you can set variables to values that came from anywhere, you can begin to see the power here.

For example, we can set n to a number that we get from the terminal.

Remember that you can get strings from the terminal using `gets`? In irb, type `s = gets`, followed by the Enter key. Then type hi and the Enter key.

<figure class="code" dir="ltr">
<div class="highlight">
<pre><code>irb&gt; s = gets
hi
=&gt; &quot;hi\n&quot;
irb&gt; s
=&gt; &quot;hi\n&quot;</code></pre>
</div>
</figure>

Also, remember that we can use `strip` to remove the newline at the end of a string?

<figure class="code" dir="ltr">
<div class="highlight">
<pre><code>irb&gt; s.strip
=&gt; &quot;hi&quot;</code></pre>
</div>
</figure>

We will do an example where we use `gets` to get a string from the terminal, `strip` to get rid of the newline, and `to_i` to turn it into a number.

In irb, type `n = gets.strip.to_i`, followed by the Enter key. Then type 8 and the Enter key.

<figure class="code" dir="ltr">
<div class="highlight">
<pre><code>irb&gt; n = gets.strip.to_i
8
=&gt; 8
irb&gt; n
=&gt; 8</code></pre>
</div>
</figure>

We can then test if n is less than 5.

<figure class="code" dir="ltr">
<div class="highlight">
<pre><code>irb&gt; n &lt; 5
=&gt; false</code></pre>
</div>
</figure>

Let's get a different number, store it in the `n` variable, and then do that test again.

<figure class="code" dir="ltr">
<div class="highlight">
<pre><code>irb&gt; n = gets.strip.to_i
4
=&gt; 4
irb&gt; n &lt; 5
=&gt; true</code></pre>
</div>
</figure>

Anyway, back at the beginning of the lesson, we said that programs are built on making decisions, based on the truth or falseness of expressions or variables.

This is done in 2 ways:

1.  deciding what to do using an `if` statement
2.  deciding how long to do something using a `while` loop

Let's look at these both now, starting with the `if` statement.

An `if` statement tests an expression or variable. If it is true, the statements inside the `if` part are executed. If it is false, the statements inside the `else` part are executed.

Here's how it works. By the way, I indent the `puts "yes"` and `puts "no"` statements with spaces, but you do not have to:

<figure class="code" dir="ltr">
<div class="highlight">
<pre><code>irb&gt; if true
irb&gt;   puts &quot;yes&quot;
irb&gt; else
irb&gt;   puts &quot;no&quot;
irb&gt; end
yes
=&gt; nil</code></pre>
</div>
</figure>

So, we only saw "yes" and not "no", since `true` is true. The poor `puts "no"` statement will never be run. The return value of this whole `if` statement is nil, which is why you see `=> nil` at the end.

Let's get the `else` part to execute:

<figure class="code" dir="ltr">
<div class="highlight">
<pre><code>irb&gt; if false
irb&gt;   puts &quot;yes&quot;
irb&gt; else
irb&gt;   puts &quot;no&quot;
irb&gt; end
no
=&gt; nil</code></pre>
</div>
</figure>

In this case, we only saw "no" and not "yes". The poor `puts "yes"` statement will never be run.

You can also test a variable:

<figure class="code" dir="ltr">
<div class="highlight">
<pre><code>irb&gt; t = true
=&gt; true
irb&gt; t
=&gt; true
irb&gt; if t
irb&gt;   puts &quot;yes&quot;
irb&gt; else
irb&gt;   puts &quot;no&quot;
irb&gt; end
yes
=&gt; nil</code></pre>
</div>
</figure>

So, Ruby printed "yes", since `t` is true.

Let's get the `else` part to execute:

<figure class="code" dir="ltr">
<div class="highlight">
<pre><code>irb&gt; t
=&gt; true
irb&gt; if !t
irb&gt;   puts &quot;yes&quot;
irb&gt; else
irb&gt;   puts &quot;no&quot;
irb&gt; end
no
=&gt; nil</code></pre>
</div>
</figure>

In this case, `t` is true, so `!t` is false.

You can use anything that produces a boolean (true or false) value in the test of an `if` statement.

For example, we can put a less than comparison in the if statement test, since it produces a boolean value:

<figure class="code" dir="ltr">
<div class="highlight">
<pre><code>irb&gt; x = 2
=&gt; 2
irb&gt; if x &lt; 3
irb&gt;   puts &quot;smaller&quot;
irb&gt; else
irb&gt;   puts &quot;bigger&quot;
irb&gt; end
smaller
=&gt; nil</code></pre>
</div>
</figure>

You can even put a function call in the `if` statement test, since its return value can be tested for truth.

Let's define a function which returns whether a number is bigger than two:

<figure class="code" dir="ltr">
<div class="highlight">
<pre><code>irb&gt; def bigger_than_two(n)
irb&gt;   n &gt; 2
irb&gt; end
=&gt; nil</code></pre>
</div>
</figure>

We can then call this function in the `if` test.

Here, we call it with 1, which is not bigger than 2. So, the function returns false, and the `else` case gets executed:

<figure class="code" dir="ltr">
<div class="highlight">
<pre><code>irb&gt; if bigger_than_two(1)
irb&gt;   puts &quot;bigger&quot;
irb&gt; else
irb&gt;   puts &quot;smaller&quot;
irb&gt; end
smaller
=&gt; nil</code></pre>
</div>
</figure>

Here, we call it with 3, which is bigger than 2. So, the function returns true, and the `if` case gets executed:

<figure class="code" dir="ltr">
<div class="highlight">
<pre><code>irb&gt; if bigger_than_two(3)
irb&gt;   puts &quot;bigger&quot;
irb&gt; else
irb&gt;   puts &quot;smaller&quot;
irb&gt; end
bigger
=&gt; nil</code></pre>
</div>
</figure>

Besides just making decisions based on boolean expressions, we can also loop based on them.

We will do this using a new programming concept: a `while` loop. A `while` loop is basically a loop that does an `if` test in every cycle through the loop, and stops the loop when the test is `false`.

Type this in irb. When you are tired of seeing "still true" being printed, hold down the `control` key and type `c` to interrupt the loop from running.

<figure class="code" dir="ltr">
<div class="highlight">
<pre><code>irb&gt; while true
irb&gt;   puts &quot;still true&quot;
irb&gt; end
still true
still true
still true
still true
still true
...</code></pre>
</div>
</figure>

In this loop, `true` is always `true`, so the while loop will run forever, unless you stop it!

When you write a computer program, you are telling the computer what to do. The computer will do exactly what you tell it to do, even if you tell it to do something as stupid as print "still true" while `true` is `true`.

By the way, what we just did is create an infinite loop, since it will go forever (unless interrupted). Usually, creating an infinite loop is a mistake (or "bug") in your program, but sometimes it is helpful to deliberately create infinte loops.

*Also, as a bit of side trivia: you are using an Apple Mac to follow along with this course, and Apple's address is 1 Infinite Loop, Cupertino, California.*

Let's make a while loop that does something a bit useful: count from 0 to 10.

<figure class="code" dir="ltr">
<div class="highlight">
<pre><code>irb&gt; i = 0
=&gt; 0
irb&gt; while i &lt;= 10
irb&gt; puts i
irb&gt; i = i + 1
irb&gt; end
0
1
2
3
4
5
6
7
8
9
10
=&gt; nil</code></pre>
</div>
</figure>

The way this works is each time through the `while` loop, we are adding 1 to i. If we did not put the `i = i + 1` statement in, the `while` loop would print `0` forever.

Throughout this course, I've been saying that programmers like me are lazy. You know how lazy we are? We don't even like typing things like `i = i + 1`. We have a shortcut way of doing that in Ruby: the `+=` operator. Let's count from 1 to 5 using `+=` to add 1 to i:

<figure class="code" dir="ltr">
<div class="highlight">
<pre><code>irb&gt; i = 1
=&gt; 1
irb&gt; while i &lt; 6
irb&gt; puts i
irb&gt; i += 1
irb&gt; end
1
2
3
4
5
=&gt; nil</code></pre>
</div>
</figure>

In many other programming languages, we can be ever lazier and say `i++` instead of `i += 1`. But we can't do that in Ruby!

## Exercises 

1.  In irb, test if 1 is equal to 1.
2.  In irb, test if 1 is equal to "1". Can you guess why it is not equal?
3.  In irb, write a function called `same` which takes 2 parameters and prints "equal" if they are equal and prints "not equal" if they are not equal. Test it with `same 1,1` and `same 1,2`. Hint: the first line of the function is `def same(a,b)`. You will use an `if` / `else` statement in the function.
4.  In irb, write a `while` loop that multiplies `1*1`, `2*2`, `3*3`, all the way up to `12*12`. Every answer should be printed on its own line, with `puts`.

You can see the [answers to the exercises](#chap14.xhtml#lesson12answers), or just continue to the quiz.

## Quiz 

 
[Take this quiz online](http://localhost:3001/courses/leanpub/programmingforkids/quizzes/quiz12)


</div>

[]{#chap13.xhtml}

<div>

# Lesson 13: The Spelt Project 

## Material 

It's amazing what you've learned so far!

In this lesson, we're going to put everything together and build our first meaningful program! This program will take advantage of almost everything we have learned in this course.

This is the last lesson in the course. It's also the longest lesson. So, you should plan to take a bit more time to work through it. I have split it into 3 sections. Feel free to take a break after each section.

## Section 1: Spelling a Word 

The program we are going to build is called "spelt", and it will be a program that you can use to teach yourself how to spell words. If you wonder where the name came from, spelt is a type of bread, and it's also the past tense of spell in the British version of English. In US English, you say spelled, not spelt -- so for you, the name of the spelt program would be spelt incorrectly. I like to make (bad) jokes for names of programs.

Anyway, enough of that. We are going to start slowly, experimenting in irb. Start irb.

Let's use `say` to say the letter h. Make sure you type the backticks at the beginning and the end of the command. (The backtick is beside the `1` key.)

<figure class="code" dir="ltr">
<div class="highlight">
<pre><code>irb&gt; `say &quot;h&quot;`
=&gt; &quot;&quot;</code></pre>
</div>
</figure>

Great, we heard "h". So, the `say` command can say individual letters. Now, let's try `say` with just a space.

<figure class="code" dir="ltr">
<div class="highlight">
<pre><code>irb&gt; `say &quot; &quot;`
=&gt; &quot;&quot;</code></pre>
</div>
</figure>

We didn't hear anything!

In our spelling program `spelt`, we are going to be spelling things using say. We will make a `say` function to help with this.

If our `say` function is given a letter, it will say the letter. Otherwise, the `say` function should say "space".

So, we're going to use a function containing an `if` statement to accomplish this.

In terminal, quit irb and then open nano by typing `nano`.

We are going to create the `say` function.

<figure class="code" dir="ltr">
<div class="highlight">
<pre><code>def say(str)
  if str == &quot; &quot;
    `say &quot;space&quot;`
  else
    `say #{str}`
  end
  str
end</code></pre>
</div>
</figure>

Note that the `if str == " "` line has a space in between the opening and closing quotes!

Here's how it works: If `say` is given a string which is `" "` (the space character), it will say "space". Otherwise, it just calls the `say` command with whatever string was passed in, using the `#{}` syntax that we learned earlier.

Finally, the `say` function returns the string that it is given. (We might as well return something, so that we can chain function calls together.)

By the way, to indent the code inside a function, use two spaces per level of indent. You don't have to indent the code if you don't want to. (My son always refuses to, since in Ruby, the spaces don't matter. But, in some languages, like Python and CoffeeScript, they do matter.) Indenting is good practice, though, since it lets you read your own programs more easily.

Let's try this. Save the file by typing `control` + `o`, typing the file name of `spelt.rb` and hitting the `Enter` key.

Nano will say "\[ Wrote 7 lines \]". (Or, if you have an extra newline at the end of the file, it will say "\[ Wrote 8 lines \]". Either is fine.

Quit nano by typing `control` + `x`.

Next, start irb again.

Load the `spelt` program by typing `load "spelt.rb"` and hitting `Enter`. Then, let's test out our `say` function, first by trying `say "hi"`', then `say "h"`, `say " "` and finally `say "hello world"`.

<figure class="code" dir="ltr">
<div class="highlight">
<pre><code>irb&gt; load &quot;spelt.rb&quot;
=&gt; true
irb&gt; say &quot;hi&quot;
=&gt; &quot;hi&quot;
irb&gt; say &quot;h&quot;
=&gt; &quot;h&quot;
irb&gt; say &quot; &quot;
=&gt; &quot; &quot;
irb&gt; say &quot;hello world&quot;
=&gt; &quot;hello world&quot;</code></pre>
</div>
</figure>

It works! When our `say` function is given only a space, it says "space". Otherwise, it says what it was given, whether it was a letter, or "hi" or "hello world".

Quit irb. Next, open `spelt.rb` in nano by typing `nano spelt.rb` and hitting `Enter`.

Next, we will add a `putsay` function to spelt, which will be similar to the one we created for our `doge` program. This function will take a string as its parameter, and it will print the string using `puts` and say the string. However, instead of using the `say` command in backticks, it will call our `say` function.

Scroll down to the bottom of the file (below the definition of the `say` function) using the down arrow. Then, add a blank line and then this function:

<figure class="code" dir="ltr">
<div class="highlight">
<pre><code>def putsay(str)
  puts str
  say str
end</code></pre>
</div>
</figure>

The `putsay` function returns the string that it is given. (We might as well return something, so that we can chain function calls.)

At this point, the `spelt.rb` program should look like this:

<figure class="code" dir="ltr">
<div class="highlight">
<pre><code>def say(str)
  if str == &quot; &quot;
    `say &quot;space&quot;`
  else
    `say #{str}`
  end
  str
end

def putsay(str)
  puts str
  say str
end</code></pre>
</div>
</figure>

Note that the last statement in the `putsay` function is a function call: `say str`. So, the `putsay` function returns the return value of this function call. So, since `say` returns the string it is given, that is what `putsay` function will also return.

Save the file by typing `control` + `o` and then hitting the `Enter` key. This will overwrite the `spelt.rb` file with our new version.

Then, quit nano by typing `control` + `x`.

Finally, start irb again and load the `spelt` program.

<figure class="code" dir="ltr">
<div class="highlight">
<pre><code>irb&gt; load &quot;spelt.rb&quot;
=&gt; true</code></pre>
</div>
</figure>

Let's test our new `putsay` function:

<figure class="code" dir="ltr">
<div class="highlight">
<pre><code>irb&gt; putsay &quot;hi&quot;
hi
=&gt; &quot;hi&quot;
irb&gt; putsay &quot; &quot;

=&gt; &quot; &quot;</code></pre>
</div>
</figure>

Now, the next thing we are going to do is write a function that spells whatever the string is, letter by letter.

But, how are we going to do this?

It turns out it is really easy!

In Ruby, strings come with a bunch of functions. One of them is called `split`, which returns an array of strings.

What `split` does is best shown by example:

<figure class="code" dir="ltr">
<div class="highlight">
<pre><code>irb&gt; &quot;this is cool&quot;.split &quot; &quot;
=&gt; [&quot;this&quot;, &quot;is&quot;, &quot;cool&quot;]</code></pre>
</div>
</figure>

The `split` function takes a string parameter which is used as a delimiter. A delimiter means a thing that splits something into pieces, like slices in a loaf of bread. It is the thing that you separate the array by.

So, calling `split` on "this is cool" with a delimiter of " " (space) turns into the array `["this", "is", "cool"]`.

The split function always returns an array of strings. Each string is the part of the string up to the first part of the string that matches the delimiter. The delimiters themselves are not included in the returned array. (There are no spaces in the array `["this", "is", "cool"]`.)

Let's try calling `split` on "123.456.789" with a delimiter of "." (period).

<figure class="code" dir="ltr">
<div class="highlight">
<pre><code>irb&gt; &quot;123.456.789&quot;.split &quot;.&quot;
=&gt; [&quot;123&quot;, &quot;456&quot;, &quot;789&quot;]</code></pre>
</div>
</figure>

Here, this splits the string `"123.456.789"` into an array containing 3 strings:

<figure class="code" dir="ltr">
<div class="highlight">
<pre><code>1. &quot;123&quot;
2. &quot;456&quot;
3. &quot;789&quot;</code></pre>
</div>
</figure>

It throws out the delimiter, which is a period.

Let's try with commas:

<figure class="code" dir="ltr">
<div class="highlight">
<pre><code>irb&gt; &quot;ruby,is,fun&quot;.split &quot;,&quot;
=&gt; [&quot;ruby&quot;, &quot;is&quot;, &quot;fun&quot;]</code></pre>
</div>
</figure>

Here, this splits the string `"ruby,is,fun"` into an array containing 3 strings:

<figure class="code" dir="ltr">
<div class="highlight">
<pre><code>1. &quot;ruby&quot;
2. &quot;is&quot;
3. &quot;fun&quot;</code></pre>
</div>
</figure>

It throws out the delimiter, which is a comma.

Finally, let's try this with a delimiter of an empty string (`""`):

<figure class="code" dir="ltr">
<div class="highlight">
<pre><code>irb&gt; &quot;hello&quot;.split &quot;&quot;
=&gt; [&quot;h&quot;, &quot;e&quot;, &quot;l&quot;, &quot;l&quot;, &quot;o&quot;]</code></pre>
</div>
</figure>

Here, there is an empty string between every letter (or "character") in the string, so this splits the string into an array of the 5 characters that make up the string.

This will let us spell words! All we need to do is use `split` to print and say each letter.

Let's use a block to do this! A block, which we saw earlier in the course, is a way of looping through something:

<figure class="code" dir="ltr">
<div class="highlight">
<pre><code>irb&gt; letters = &quot;hello&quot;.split &quot;&quot;
=&gt; [&quot;h&quot;, &quot;e&quot;, &quot;l&quot;, &quot;l&quot;, &quot;o&quot;]
irb&gt; letters.each do |letter|
irb&gt; putsay letter
irb&gt; end
h
e
l
l
o
=&gt; [&quot;h&quot;, &quot;e&quot;, &quot;l&quot;, &quot;l&quot;, &quot;o&quot;]</code></pre>
</div>
</figure>

As a piece of advice, you should try to keep your code as simple as possible. That way, when (not if!) things go wrong with it, you will have an easier time finding the mistakes, or "bugs" in your code. If you make your code complicated just to show off, you will end up wasting your own time later!

Quit irb.

Next, open `spelt.rb` in nano by typing `nano spelt.rb` and hitting `Enter`.

We're going to make a spell function. Now, in English, we don't normally write one letter per line. So, we're going to make a slight changes to what we did in irb: we are going to say every letter without printing it. So, we will use the `say` function we wrote, not the `putsay` function. If we want to print the word, we can always just print it using puts.

<figure class="code" dir="ltr">
<div class="highlight">
<pre><code>def spell(str)
  str.split(&quot;&quot;).each do |char|
    say char
  end
  str
end</code></pre>
</div>
</figure>

The first `end` is to end the do ... end loop over the characters (`char`) of the string `str`. (For StarCraft players: Here, `char` is for "character", not for the Zerg homeworld!) The second `end` is to end the function. Indenting our code helps us keep track of the `def ... end` and `do ... end` pairs.

At this point, the `spelt.rb` program should look like this:

<figure class="code" dir="ltr">
<div class="highlight">
<pre><code>def say(str)
  if str == &quot; &quot;
    `say &quot;space&quot;`
  else
    `say #{str}`
  end
  str
end

def putsay(str)
  puts str
  say str
end

def spell(str)
  str.split(&quot;&quot;).each do |char|
    say char
  end
  str
end</code></pre>
</div>
</figure>

Save the file by typing `control` + `o` and then hitting the `Enter` key. This will overwrite the `spelt.rb` file with our new version.

Then, quit nano by typing `control` + `x`.

Finally, start irb again and load the `spelt` program.

<figure class="code" dir="ltr">
<div class="highlight">
<pre><code>irb&gt; load &quot;spelt.rb&quot;
=&gt; true</code></pre>
</div>
</figure>

We are going to test the `spell` function:

<figure class="code" dir="ltr">
<div class="highlight">
<pre><code>irb&gt; spell &quot;hello world&quot;
=&gt; &quot;hello world&quot;</code></pre>
</div>
</figure>

You should have heard:
`h e l l o space w o r l d`

Awesome! This might be a good point to take a small break. You're about a third of the way through this last lesson!

## Section 2: Finishing Spelt 

What to do next?

Well, if we're writing a spelling program, we need to have a way of defining a list of words that we should learn how to spell, right?

Luckily, we already have one: two lessons ago, we wrote a program called `doge` where we read a list of words out of a file that had 1 word per line!

This approach would be absolutely perfect for our `spelt` program. What a coincidence! (wow, so amaze, wow :)

Quit irb.

Next, open `spelt.rb` in nano by typing

`nano spelt.rb`

and hitting `Enter`.

Add this code to the bottom of the `spelt` program. By the way, since this is a lot of typing, feel free to select the text, copy it to the clipboard with `command` + `c`, and paste it into nano with `command` + `v`. You will need to reformat it though, to look like this...

<figure class="code" dir="ltr">
<div class="highlight">
<pre><code>words = File.readlines &quot;words.txt&quot;
words.map! {|line| line.strip}
words.reject! {|line| line.empty?}
num_words = words.length
putsay &quot;Welcome to Spelt!&quot;
putsay &quot;We will spell #{num_words} words.&quot;
num_right = 0
words.each do |word|
  say &quot;spell #{word}&quot;
  answer = gets.strip
  if word == answer
    num_right = num_right + 1
    say &quot;awesome&quot;
  else
    say &quot;wrong&quot;
  end
end
putsay &quot;You got #{num_right}&quot; +
&quot; out of #{num_words}!&quot;</code></pre>
</div>
</figure>

Here's what this code does:

1.  We read all the lines in the `words.txt` file into an array, which is stored in a variable called `words`. We are assuming there is a maximum of 1 word per line.
2.  We then get rid of the newlines using `map!`. What `map!` does is modifies the array it is called on, and replaces each element of the array with the result of doing what is inside the block. For us, we are calling `strip` on the line. So, this code removes all the newlines.
3.  We then get rid of the blank lines using `reject`.
4.  We get the number of words with `words.length` and store the number in `num_words`. Arrays also have a `length` function which gets how long the array is.
5.  We use `putsay` to print and say "Welcome to Spelt".
6.  We use `putsay` to say how many words we are going to spell.
7.  We create a variable called `num_right` which will count the number of right answers.
8.  We then loop over all the words using a block. For each word, we do this:

a\) We say "spell" and the word.
b) We get a line of input from the keyboard using `gets.strip` (which you saw earlier in the course) and store it in a variable called `answer`.
c) We check if the word is the same as the answer using another if statement, `if word == answer`. If the if statement is true, then the user spelled the word right, so we add 1 to our count of right answers and then say "awesome". If the if statement is not true, then we say "wrong".
9. At the end, we say how many words were spelled right out of the total number of words. Normally you would say `putsay "You got #{num_right} out of #{num_words}!"` instead of doing this on 2 lines with `putsay "You got #{num_right}" +` and `" out of #{num_words}!"`. However, I did it this way so that the code did not break in the middle of the line in the course.

By the way, this type of sequence of steps, loops and decisions has a really fancy name: an algorithm.

An algorithm ("al go rith um") is the approach that we can use to solve a problem. When we write algorithms, we typically combine a sequence of steps with if/else statements and loops that make decisions. So, when we are writing computer programs and solving problems, we first come up with the algorithm and then we write the code.

Don't let the fancy name fool you: you use algorithms all the time. Lots of the math you learn at school, stuff like 2 digit multiplication and long division, is just you learning an algorithm. The steps you learn are the algorithm, and you are being taught how to "play computer" to use the algorithm to solve the problem.

Anyway, here's what the full `spelt` program looks like. Make sure that your program looks like this:

<figure class="code" dir="ltr">
<div class="highlight">
<pre><code>def say(str)
  if str == &quot; &quot;
    `say &quot;space&quot;`
  else
    `say #{str}`
  end
  str
end

def putsay(str)
  puts str
  say str
end

def spell(str)
  str.split(&quot;&quot;).each do |char|
    say char
  end
  str
end

words = File.readlines &quot;words.txt&quot;
words.map! {|line| line.strip}
words.reject! {|line| line.empty?}
num_words = words.length
putsay &quot;Welcome to Spelt!&quot;
putsay &quot;We will spell #{num_words} words.&quot;
num_right = 0
words.each do |word|
  say &quot;spell #{word}&quot;
  answer = gets.strip
  if word == answer
    num_right = num_right + 1
    say &quot;awesome&quot;
  else
    say &quot;wrong&quot;
  end
end
putsay &quot;You got #{num_right}&quot; +
&quot; out of #{num_words}!&quot;</code></pre>
</div>
</figure>

Save the file by typing `control` + `o` and then hitting the `Enter` key. This will overwrite the `spelt.rb` file with our new version.

Then, quit nano by typing `control` + `x`.

Run your new program by typing `ruby spelt.rb` and hit Enter.

You will see the following:

<figure class="code" dir="ltr">
<div class="highlight">
<pre><code>~/stuff[]$ ruby spelt.rb
Welcome to Spelt!
We are going to spell 4 words.</code></pre>
</div>
</figure>

(Ignore the `~/stuff[]$`, that is just what my prompt looks like.)

You will hear "spell apple".

Let's deliberately make a mistake. Type `a` + `Enter` instead of `apple`. Then correctly spell `banana`, `peach` and `pear`.

You will see this:

<figure class="code" dir="ltr">
<div class="highlight">
<pre><code>~/stuff[]$ ruby spelt.rb
Welcome to Spelt!
a
banana
peach
pear
You got 3 out of 4!</code></pre>
</div>
</figure>

Also, if you had your sound on, you should have heard your program!

This might be a good point to take another small break. You're about two thirds of the way through this last lesson!

## Section 3: Enhancing Spelt 

One of the great things about programming is that you can constantly challenge yourself to improve! You can constantly improve your programs, and your skill as a programmer.

In this final section, we will do both, by enhancing our `spelt` program in two ways.

First, just saying "wrong" when the user spells something wrong is not very helpful. Let's make the `spelt` program teach the spelling of a word when it is spelled wrong!

We are going to delete the

<figure class="code" dir="ltr">
<div class="highlight">
<pre><code>    say &quot;wrong&quot;</code></pre>
</div>
</figure>

line and add a while loop instead. The rest of the program is unchanged, so I'm skipping writing it down here and showing `...` instead:

<figure class="code" dir="ltr">
<div class="highlight">
<pre><code>...
words.each do |word|
  say &quot;spell #{word}&quot;
  answer = gets.strip
  if word == answer
    num_right = num_right + 1
    say &quot;awesome&quot;
  else
    say &quot;wrong&quot;
    while word != answer
      say &quot;The correct spelling is&quot;
      puts word
      spell word
      say &quot;not&quot;
      spell answer
      say &quot;try again&quot;
      say &quot;spell #{word}&quot;
      answer = gets.strip
    end
    say &quot;great job&quot;
  end
end
putsay &quot;You got #{num_right}&quot; +
&quot; out of #{num_words}!&quot;</code></pre>
</div>
</figure>

Here's what this code does:

It loops while the word is not equal (`!=`) to the answer. In each pass through the loop, the code...

1.  says "The correct spelling is"
2.  prints the `word` with puts
3.  calls the `spell` function to spell the `word`
4.  says "not"
5.  says the spelling that the user provided as the `answer`
6.  says "try again"
7.  says "spell" and the `word` being spelt
8.  gets a new answer and removes the newline using `gets.strip`

Then, the loop goes back to the beginning. It tests again whether the `word` is not equal to the answer. If it is not equal, we loop again. (So, if the user is unable to learn spelling, we have an infinite loop!)

If the spelling is equal, the loop finishes and we say "great job".

Now, asking the user to spell a word when you are showing them the word is not that difficult. Let's fix that. There is a command called `clear` that clears the Terminal window in Mac.

Add a function called `cls` (for "clear screen") to the top of your `spelt` program.

<figure class="code" dir="ltr">
<div class="highlight">
<pre><code>def cls
  print `clear`
end</code></pre>
</div>
</figure>

We are then going to call this new `cls` function from 4 places in the program. (There are 3 uses of cls on the first page, and one on the second page.) The rest of the code is the same.

<figure class="code" dir="ltr">
<div class="highlight">
<pre><code>...
words = File.readlines &quot;words.txt&quot;
words.map! {|line| line.strip}
words.reject! {|line| line.empty?}
num_words = words.length
cls
putsay &quot;Welcome to Spelt!&quot;
putsay &quot;We will spell #{num_words} words.&quot;
num_right = 0
words.each do |word|
  say &quot;spell #{word}&quot;
  answer = gets.strip
  if word == answer
    num_right = num_right + 1
    say &quot;awesome&quot;
    cls
  else
    while word != answer
      say &quot;The correct spelling is&quot;
      puts word
      spell word
      say &quot;not&quot;
      spell answer
      cls
      say &quot;try again&quot;
      say &quot;spell #{word}&quot;
      answer = gets.strip
    end
    say &quot;great job&quot;
  end
end
cls
putsay &quot;You got #{num_right}&quot; +
&quot; out of #{num_words}!&quot;</code></pre>
</div>
</figure>

Save the file by typing `control` + `o` and then hitting the `Enter` key. This will overwrite the `spelt.rb` file with our new version.

Then, quit nano by typing `control` + `x`.

As a treat, I'm going to show you what this code looks like, with syntax highlighting turned on. (I haven't been showing the examples in the course with syntax highlighting, since I didn't want you to rely on it.)

\<\<(code/spelt.rb)

By the way, if you're wondering how to see syntax highlighting when you write code, you can't do that in nano. Other text editors, like [Sublime Text](http://www.sublimetext.com/) and [Emacs](http://emacsformacosx.com/) let you do this.

Run your new program by typing `ruby spelt.rb` and hit Enter.

You will see the screen get cleared at the right times. Also, if you spell a word wrong, `spelt` will show it to you, spell it to you, and then test you again.

Great job! This was the most complex program you've ever written!

You should be very, very proud of yourself for what you have learned in this course.

## Exercises 

These final exercises are a bit different. You're going to read code, and then make small changes. Lots of being a programmer involves being able to read, understand and modify code, not just write it from scratch.

Below is a ruby program called `table` that lets you practice times tables.

Just like `spelt`, it uses a `say` and a `putsay` function, so the program talks to you as well as printing output.

<figure class="code" dir="ltr">
<div class="highlight">
<pre><code>def say(str)
  `say #{str}`
  str
end

def putsay(str)
  puts str
  say str
end

putsay &quot;Welcome to table!&quot;
putsay &quot;We are going to learn times tables.&quot;
putsay &quot;What number do you want to stop at?&quot;
max = gets.to_i
num_right = 0
num_questions = 0
i = 1
while i &lt;= max
  j = 1
  while j &lt;= max
    putsay &quot;What is #{i} times #{j}?&quot;
    answer = gets.to_i
    num_questions += 1
    right = i*j
    if answer == right
      putsay &quot;Awesome!&quot;
      num_right += 1
    else
      putsay &quot;Wrong!&quot;
    end
    j += 1
  end
  i += 1
end
putsay &quot;You got #{num_right}&quot; +
&quot; out of #{num_questions}.&quot;</code></pre>
</div>
</figure>

Notes:

1.  The `say` function does not need to handle spaces in a special way, unlike in the `spelt` program.
2.  We are going to get the maximum from the user, and loop between 1 and max.
3.  We use nested while loops in this program, since it's the easiest thing to do!

### Question 1 

Make a new file in the `stuff` directory called `table.rb`. Copy the text of this program and paste it in. To copy the text, you select it in Preview, then type `command` + `c` to copy. Then, start nano by typing `nano` it Terminal. When in nano, paste the text by typing `command` + `v`. Since the program goes across 2 pages, you will have to do this for each page. Also, when you paste, lots of the newlines and indenting might be removed. You'll need to fix that by using the arrow keys to go to the right place, and the space bar or Enter keys to format the code properly.

Run the program with `ruby table.rb` and play along. (Enter 2 for the number you want to stop at. After the first run with stopping at 2, you can also use a larger number if you want to practice times tables.)

[See the answer.](#chap14.xhtml#lesson13q1)

### Question 2 

Change the code to print and say "Yay!" when the user gets the question right (instead of "Awesome!"). Open the table.rb file by typing `nano table.rb`. Save, quit and test, entering 3 as the number you want to stop at.

[See the answer.](#chap14.xhtml#lesson13q2)

### Question 3 

Change the code to only multiply by even numbers (2,4,6,8,...) in the times table. Start at 2, and go up to the largest even number less than or equal to max. Save, quit and test, entering 5 as the number you want to stop at.

This is a hard question! Think about it for a while. I'm going to give you 3 hints, one per page, starting on the next page. See how many hints you need before you [look at the answer.](#chap14.xhtml#lesson13q3)

 page-break


#### Hint #1 for Question 3 

You just have to change 4 lines of code. You do not need to add or delete any lines of code.

 page-break


#### Hint #2 for Question 3 

You need to count by 2's, not by 1's.

 page-break


#### Hint #3 for Question 3 

If you don't change the starting number, you'll be counting odd numbers, not even ones!

[See the answer.](#chap14.xhtml#lesson13q3)

## Quiz 

 
[Take this quiz online](http://localhost:3001/courses/leanpub/programmingforkids/quizzes/quiz13)


</div>

[]{#chap14.xhtml}

<div>

# Appendices 

## About the Author 

This course was written by [Peter Armstrong](https://leanpub.com/u/peter), the co-founder and CEO of Leanpub.

Peter is also the author of 7 books: Yoshidaguchi, Your First Trip to Japan, The Markua Specification, Programming for Kids, Lean Publishing, Flexible Rails and Hello! Flex 4. He has a BSc in Computer Science and Psychology from the University of Victoria.

Peter coined the term "lean publishing" to describe the act of self-publishing an in-progress ebook. Leanpub was created based on the principles of lean publishing. He lives in Victoria, BC with his wife and son.

## About the Cover 

The cover [photo](https://unsplash.com/photos/YoC_rDkSS1U) is by [Gareth Newstead](http://www.garethnewsteadphotography.com/?utm_medium=referral&utm_source=unsplash) and is from [Unsplash](https://unsplash.com/).

## About Leanpub 

This is a Leanpub course. I'm the cofounder of Leanpub. Leanpub is a website which lets anyone publish their own books and courses as they write them. The idea of publishing an in-progress ebook or course is something I call Lean Publishing. You can learn more about Lean Publishing by reading a [free book](https://leanpub.com/lean) that I wrote last year.

Besides being totally free to use, being a Leanpub author can also be profitable. We pay authors 80% royalties per copy sold. So, a \$10 ebook pays \$8 in royalties per copy!

## Answers to the Exercises 

### Lesson 1 Answers 

#### Question 1 

You start Terminal and `cd` into the `stuff` directory by doing this:

1.  In Finder, type `Command + Space` to start Spotlight
2.  Type `terminal`
3.  Hit the Enter key
4.  Type `cd stuff` in Terminal and hit `Enter`.

You will now be in Terminal in the `stuff` directory.

#### Question 2 

To start nano, just type `nano` in the Terminal window, and hit Enter.

You will now be in nano.

Type `hooray`.

Hold down the `Control` key and typo `o`. Type `hooray.txt` and press Enter. Nano will say "Wrote 1 line" (or "Wrote 2 lines", if you hit Enter after typing `hooray`).

Hold down the `Control` key and type `x` to quit nano.

#### Question 3 

Type `cat hooray.txt` to see the contents of hooray.txt.

You will see something like this:

<figure class="code" dir="ltr">
<div class="highlight">
<pre><code>~/stuff[]$ cat hooray.txt
hooray</code></pre>
</div>
</figure>

#### Question 4 

To quit Terminal, type `Command + Q` or choosing Quit Terminal from the Terminal menu.

 
<figure class="image block">
<img src="resources/2025-08-03T011754-113Z-042f7910-cac3-4014-bf5b-10cba15c17ca-20250803011756/resources/images----quittingterminal.png" />
</figure>


#### Continue Reading 

If this was confusing, please [read lesson 1 again](#chap14.xhtml#lesson1).

If this made sense, please [continue to the lesson 1 quiz](#chap01.xhtml#lesson1quiz).

### Lesson 2 Answers 

#### Question 1 

To start nano, type `nano` in a Terminal window, and hit Enter. You will now be in nano. Type `puts "Hi!"`. To type `!`, hold the `shift` key and type 1.

To save the file, hold down the `Control` key and typo `o`. Type `hi.rb` and press Enter. Nano will say "Wrote 1 line" (or "Wrote 2 lines", if you hit Enter after the `puts "Hi!"`).

Hold down the `Control` key and type `x` to quit nano.

In Terminal, type `ruby hi.rb` and hit `Enter`. You need a space between `ruby` and `hi.rb`.

You will see something like this:

<figure class="code" dir="ltr">
<div class="highlight">
<pre><code>~/stuff[]$ ruby hi.rb
Hi!</code></pre>
</div>
</figure>

#### Continue Reading 

If this was confusing, please [read lesson 2 again](#chap02.xhtml#lesson2).

If this made sense, please [continue to the lesson 2 quiz](#chap02.xhtml#lesson2quiz).

### Lesson 3 Answers 

#### Question 1 

<figure class="code" dir="ltr">
<div class="highlight">
<pre><code>irb&gt; 3 - 2
=&gt; 1</code></pre>
</div>
</figure>

#### Question 2 

<figure class="code" dir="ltr">
<div class="highlight">
<pre><code>irb&gt; 3.0 / 2
=&gt; 1.5</code></pre>
</div>
</figure>

`3.0` divided by `2` produces `1.5`. Since at least one of the numerator or denominator had a decimal point in it, the result was calculated as a floating point number.

#### Question 3 

<figure class="code" dir="ltr">
<div class="highlight">
<pre><code>irb&gt; 3 / 2
=&gt; 1</code></pre>
</div>
</figure>

`3` divided by `2` produces `1`. Since neither the numerator or denominator had a decimal point in it, the result was calculated as an integer. With integer division, the remainder is thrown away. Again, don't blindly trust a computer. Think for yourself.

#### Continue Reading 

If this was confusing, please [read lesson 3 again](#chap03.xhtml#lesson3).

If this made sense, please [continue to the lesson 3 quiz](#chap03.xhtml#lesson3quiz).

### Lesson 4 Answers 

#### Question 1 

<figure class="code" dir="ltr">
<div class="highlight">
<pre><code>irb&gt; def quad(x)
irb&gt; x*4
irb&gt; end
=&gt; nil</code></pre>
</div>
</figure>

To test the function, you can either use brackets or not.

<figure class="code" dir="ltr">
<div class="highlight">
<pre><code>irb&gt; quad 3
=&gt; 12
irb&gt; quad(3)
=&gt; 12</code></pre>
</div>
</figure>

#### Question 2 

<figure class="code" dir="ltr">
<div class="highlight">
<pre><code>irb&gt; def quad2(x)
irb&gt; x + x + x + x
irb&gt; end
=&gt; nil</code></pre>
</div>
</figure>

To test the function, you can either use brackets or not.

<figure class="code" dir="ltr">
<div class="highlight">
<pre><code>irb&gt; quad2 3
=&gt; 12
irb&gt; quad2(3)
=&gt; 12</code></pre>
</div>
</figure>

Note that if you do not use brackets, you need to have a space between the function name and its argument. You cannot say `quad23`, since Ruby has no way of figuring out what you mean!

<figure class="code" dir="ltr">
<div class="highlight">
<pre><code>irb&gt; quad23
NameError: undefined local variable or
method `quad23&#39; for main:Object
	from (irb):39
	from :0
irb&gt;</code></pre>
</div>
</figure>

#### Question 3 

You need to write this function using brackets around the function call:

<figure class="code" dir="ltr">
<div class="highlight">
<pre><code>irb&gt; def quad3(x)
irb&gt; double(x) + double(x)
irb&gt; end
=&gt; nil</code></pre>
</div>
</figure>

Note that if you don't do this, Ruby won't be able to figure out what you are doing. Usually, Ruby is smart enough to do this, but in this case it is not:

<figure class="code" dir="ltr">
<div class="highlight">
<pre><code>irb&gt; def quad3(x)
irb&gt; double x + double x
irb&gt; end
SyntaxError: compile error
(irb):28: syntax error, unexpected
tIDENTIFIER, expecting kDO or
&#39;{&#39; or &#39;(&#39;
	from (irb):29
	from :0
irb&gt;</code></pre>
</div>
</figure>

Also, note that you could have written this function another way, by just doubling what you got from doubling x once:

<figure class="code" dir="ltr">
<div class="highlight">
<pre><code>irb&gt; def quad3(x)
irb&gt; double double x
irb&gt; end
=&gt; nil
irb&gt; quad3 3
=&gt; 12</code></pre>
</div>
</figure>

If that didn't make total sense, don't worry: we'll look at this more in the Functions 2 lesson later on.

Also, if you want, you can put your function calls in brackets. As you saw above, sometimes you need to do this to let Ruby figure out what you mean. (This is not one of those cases, though.)

<figure class="code" dir="ltr">
<div class="highlight">
<pre><code>irb&gt; def quad3(x)
irb&gt; double(double(x))
irb&gt; end
=&gt; nil
irb&gt; quad3 3
=&gt; 12</code></pre>
</div>
</figure>

#### Continue Reading 

If this was confusing, please [read lesson 4 again](#chap04.xhtml#lesson4).

If this made sense, please [continue to the lesson 4 quiz](#chap04.xhtml#lesson4quiz).

### Lesson 5 Answers 

#### Question 1 

Start nano and add the code below that is in **`bold`** text.

<figure class="code" dir="ltr">
<div class="highlight">
<pre><code>def double(x)
x*2
end

def triple(y)
y*3
end

def quadruple(z)
z*4
end

puts double 2
puts triple 3
puts quadruple 4</code></pre>
</div>
</figure>

Save the file and run `ruby times.rb`.

<figure class="code" dir="ltr">
<div class="highlight">
<pre><code>~/stuff[]$ ruby times.rb
4
9
16
~/stuff[]$</code></pre>
</div>
</figure>

#### Continue Reading 

If this was confusing, please [read lesson 5 again](#chap05.xhtml#lesson5).

If this made sense, please [continue to the lesson 5 quiz](#chap05.xhtml#lesson5quiz).

### Lesson 6 Answers 

#### Question 1 

<figure class="code" dir="ltr">
<div class="highlight">
<pre><code>irb&gt; def times6(x)
irb&gt; double triple x
irb&gt; end
=&gt; nil
irb&gt; times6 6
=&gt; 36</code></pre>
</div>
</figure>

#### Question 2 

<figure class="code" dir="ltr">
<div class="highlight">
<pre><code>irb&gt; def times12(x)
irb&gt; double double triple x
irb&gt; end
=&gt; nil
irb&gt; times12 12
=&gt; 144</code></pre>
</div>
</figure>

#### Question 3 

<figure class="code" dir="ltr">
<div class="highlight">
<pre><code>irb&gt; def times12b(x)
irb&gt; double times6 x
irb&gt; end
=&gt; nil
irb&gt; times12b 12
=&gt; 144</code></pre>
</div>
</figure>

#### Question 4 

Add the code in **`bold`** to times.rb.

<figure class="code" dir="ltr">
<div class="highlight">
<pre><code>def double(x)
x*2
end

def triple(y)
y*3
end

def quadruple(z)
z*4
end

def times6(x)
double triple x
end

def times12(x)
double times6 x
end

puts double 2
puts triple 3
puts quadruple 4
puts times6 6
puts times12 12</code></pre>
</div>
</figure>

You can test this by running `ruby times.rb`:

<figure class="code" dir="ltr">
<div class="highlight">
<pre><code>~/stuff[]$ ruby times.rb
4
9
16
36
144
~/stuff[]$</code></pre>
</div>
</figure>

#### Continue Reading 

If this was confusing, please [read lesson 6 again](#chap06.xhtml#lesson6).

If this made sense, please [continue to the lesson 6 quiz](#chap06.xhtml#lesson6quiz).

### Lesson 7 Answers 

#### Question 1 

Modify the code in **`bold`** in times.rb.

<figure class="code" dir="ltr">
<div class="highlight">
<pre><code>def double(x)
x*2
end

def triple(y)
y*3
end

def quadruple(z)
z*4
end

def times6(x)
double triple x
end

def times12(x)
double times6 x
end

puts &quot;2 * 2 is #{double 2}&quot;
puts &quot;3 * 3 is #{triple 3}&quot;
puts &quot;4 * 4 is #{quadruple 4}&quot;
puts &quot;6 * 6 is #{times6 6}&quot;
puts &quot;12 * 12 is #{times12 12}&quot;</code></pre>
</div>
</figure>

You can test this by running `ruby times.rb`:

<figure class="code" dir="ltr">
<div class="highlight">
<pre><code>~/stuff[]$ ruby times.rb
2 * 2 is 4
3 * 3 is 9
4 * 4 is 16
6 * 6 is 36
12 * 12 is 144
~/stuff[]$</code></pre>
</div>
</figure>

#### Question 2 

I don't know your name, so I can't say what will be here. My name is Peter, so this is what it looks like for me:

<figure class="code" dir="ltr">
<div class="highlight">
<pre><code>irb&gt; &quot;Peter&quot;.reverse
=&gt; &quot;reteP&quot;</code></pre>
</div>
</figure>

#### Continue Reading 

If this was confusing, please [read lesson 7 again](#chap07.xhtml#lesson7).

If this made sense, please [continue to the lesson 7 quiz](#chap07.xhtml#lesson7quiz).

### Lesson 8 Answers 

#### Question 1 

<figure class="code" dir="ltr">
<div class="highlight">
<pre><code>irb&gt; a = 4
=&gt; 4</code></pre>
</div>
</figure>

Yes, that *was* an easy question!

#### Question 2 

<figure class="code" dir="ltr">
<div class="highlight">
<pre><code>irb&gt; b = a * 5
=&gt; 20</code></pre>
</div>
</figure>

You could also have written `b = 5 * a`. The order does not matter.

#### Question 3 

<figure class="code" dir="ltr">
<div class="highlight">
<pre><code>irb&gt; c = &quot;hello world&quot;
=&gt; &quot;hello world&quot;</code></pre>
</div>
</figure>

Note that if you forget the quotes, you will get this:

<figure class="code" dir="ltr">
<div class="highlight">
<pre><code>irb&gt; c = hello world
NameError: undefined local variable or
method `world&#39; for main:Object
	from (irb):12
	from :0
irb&gt;</code></pre>
</div>
</figure>

#### Question 4 

Since we just assigned the string "hello world" to c, we can save some typing!

<figure class="code" dir="ltr">
<div class="highlight">
<pre><code>irb&gt; d = c.length
=&gt; 11</code></pre>
</div>
</figure>

We can also do this the long way:

<figure class="code" dir="ltr">
<div class="highlight">
<pre><code>irb&gt; d = &quot;hello world&quot;.length
=&gt; 11</code></pre>
</div>
</figure>

#### Continue Reading 

If this was confusing, please [read lesson 8 again](#chap08.xhtml#lesson8).

If this made sense, please [continue to the lesson 8 quiz](#chap08.xhtml#lesson8quiz).

### Lesson 9 Answers 

#### Question 1 

<figure class="code" dir="ltr">
<div class="highlight">
<pre><code>irb&gt; def hi
irb&gt; n = gets
irb&gt; &quot;Hello &quot; + n.strip
irb&gt; end
=&gt; nil
irb&gt; hi
Peter
=&gt; &quot;Hello Peter&quot;</code></pre>
</div>
</figure>

#### Question 2 

<figure class="code" dir="ltr">
<div class="highlight">
<pre><code>irb&gt; def cat
irb&gt; puts &quot;string&quot;
irb&gt; a = gets.strip
irb&gt; puts &quot;string&quot;
irb&gt; b = gets.strip
irb&gt; a + b
irb end
=&gt; nil
irb&gt; cat
string
one
string
two
=&gt; &quot;onetwo&quot;</code></pre>
</div>
</figure>

#### Continue Reading 

If this was confusing, please [read lesson 9 again](#chap09.xhtml#lesson9).

If this made sense, please [continue to the lesson 9 quiz](#chap09.xhtml#lesson9quiz).

### Lesson 10 Answers 

#### Question 1 

<figure class="code" dir="ltr">
<div class="highlight">
<pre><code>irb&gt; a.map! {|i| i-1}
=&gt; [1, 2, 3, 4, 5]
irb&gt; a
=&gt; [1, 2, 3, 4, 5]</code></pre>
</div>
</figure>

#### Question 2 

<figure class="code" dir="ltr">
<div class="highlight">
<pre><code>irb&gt; b.map! {|i| i.reverse}
=&gt; [&quot;cake&quot;, &quot;is&quot;, &quot;tasty&quot;]
irb&gt; b
=&gt; [&quot;cake&quot;, &quot;is&quot;, &quot;tasty&quot;]</code></pre>
</div>
</figure>

#### Question 3 

<figure class="code" dir="ltr">
<div class="highlight">
<pre><code>irb&gt; b.each {|i| puts i}
cake
is
tasty
=&gt; [&quot;cake&quot;, &quot;is&quot;, &quot;tasty&quot;]</code></pre>
</div>
</figure>

Alternatively, you can say:

<figure class="code" dir="ltr">
<div class="highlight">
<pre><code>irb&gt; b.each do |i|
irb&gt; puts i
irb&gt; end
cake
is
tasty
=&gt; [&quot;cake&quot;, &quot;is&quot;, &quot;tasty&quot;]</code></pre>
</div>
</figure>

#### Question 4 

<figure class="code" dir="ltr">
<div class="highlight">
<pre><code>irb&gt; a.each {|i| puts i+3}
4
5
6
7
8
=&gt; [1, 2, 3, 4, 5]</code></pre>
</div>
</figure>

Alternatively, you can say:

<figure class="code" dir="ltr">
<div class="highlight">
<pre><code>irb&gt; a.each do |i|
irb&gt; puts i+3
irb&gt; end
4
5
6
7
8
=&gt; [1, 2, 3, 4, 5]</code></pre>
</div>
</figure>

#### Question 5 

<figure class="code" dir="ltr">
<div class="highlight">
<pre><code>irb&gt; a.each {|i| puts i*i}
1
4
9
16
25
=&gt; [1, 2, 3, 4, 5]</code></pre>
</div>
</figure>

Alternatively, you can say:

<figure class="code" dir="ltr">
<div class="highlight">
<pre><code>irb&gt; a.each do |i|
irb&gt; puts i*i
irb&gt; end
1
4
9
16
25
=&gt; [1, 2, 3, 4, 5]</code></pre>
</div>
</figure>

#### Continue Reading 

If this was confusing, please [read lesson 10 again](#chap10.xhtml#lesson10).

If this made sense, please [continue to the lesson 10 quiz](#chap10.xhtml#lesson10quiz).

### Lesson 11 Answers 

#### Question 1 

Add the line that is in **`bold`**. Besides that, the rest of the code is unchanged.

<figure class="code" dir="ltr">
<div class="highlight">
<pre><code>def putsay(str)
  puts str
  `say #{str}`
end

lines = File.readlines &quot;words.txt&quot;
lines.map! {|line| line.strip}
lines.reject! {|line| line.empty?}
lines.reverse!
putsay &quot;wow&quot;
lines.each do |line|
  putsay line
end
putsay &quot;so amaze&quot;</code></pre>
</div>
</figure>

#### Question 2 

Add the line that is in **`bold`**, and delete the line in strikethrough. Besides that, the rest of the code is unchanged.

<figure class="code" dir="ltr">
<div class="highlight">
<pre><code>def putsay(str)
  puts str
  `say #{str}`
end

lines = File.readlines &quot;words.txt&quot;
lines.map! {|line| line.strip}
lines.reject! {|line| line.empty?}
lines.reverse! {|line| line.empty?}
lines.shuffle! {|line| line.empty?}
putsay &quot;wow&quot;
lines.each do |line|
  putsay line
end
putsay &quot;so amaze&quot;</code></pre>
</div>
</figure>

Note that since we are randomizing the order with `shuffle!`, we also got rid of the call to `reverse!`. There's no reason to reverse the order if we are just going to randomize it.

#### Continue Reading 

If this was confusing, please [read lesson 11 again](#chap11.xhtml#lesson11).

If this made sense, please [continue to the lesson 11 quiz](#chap11.xhtml#lesson11quiz).

### Lesson 12 Answers 

#### Question 1 

<figure class="code" dir="ltr">
<div class="highlight">
<pre><code>irb&gt; 1 == 1
=&gt; true</code></pre>
</div>
</figure>

#### Question 2 

<figure class="code" dir="ltr">
<div class="highlight">
<pre><code>irb&gt; 1 == &quot;1&quot;
=&gt; false</code></pre>
</div>
</figure>

This is false because the number 1 and the string "1" are different types.

 page-break


#### Question 3 

<figure class="code" dir="ltr">
<div class="highlight">
<pre><code>irb&gt; def same(a,b)
irb&gt; if a == b
irb&gt; puts &quot;equal&quot;
irb&gt; else
irb&gt; puts &quot;not equal&quot;
irb&gt; end
irb&gt; end
=&gt; nil
irb&gt; same 1,1
equal
=&gt; nil
irb&gt; same 1,2
not equal
=&gt; nil
irb&gt;</code></pre>
</div>
</figure>

 page-break


#### Question 4 

<figure class="code" dir="ltr">
<div class="highlight">
<pre><code>irb&gt; i = 1
=&gt; 1
irb&gt; while i &lt;= 12
irb&gt; puts i*i
irb&gt; i += 1
irb&gt; end
1
4
9
16
25
36
49
64
81
100
121
144
=&gt; nil</code></pre>
</div>
</figure>

#### Continue Reading 

If this was confusing, please [read lesson 12 again](#chap12.xhtml#lesson12).

If this made sense, please [continue to the lesson 12 quiz](#chap12.xhtml#lesson12quiz).

### Lesson 13 Answers 

#### Question 1 

<figure class="code" dir="ltr">
<div class="highlight">
<pre><code>~/stuff[]$ ruby table.rb
Welcome to table!
We are going to learn times tables.
What number do you want to stop at?
2
What is 1 times 1?
1
Awesome!
What is 1 times 2?
2
Awesome!
What is 2 times 1?
2
Awesome!
What is 2 times 2?
3
No, 2 times 2 is 4.
You got 3 out of 4.
~/stuff[]$</code></pre>
</div>
</figure>

#### Question 2 

<figure class="code" dir="ltr">
<div class="highlight">
<pre><code>...
    if answer == right
      putsay &quot;Awesome!&quot;
      putsay &quot;Yay!&quot;
      num_right += 1
    else
      putsay &quot;Wrong!&quot;
    end
...</code></pre>
</div>
</figure>

#### Question 3 

<figure class="code" dir="ltr">
<div class="highlight">
<pre><code>...
putsay &quot;What number do you want to stop at?&quot;
max = gets.to_i
num_right = 0
num_questions = 0
i = 2
while i &lt;= max
  j = 2
  while j &lt;= max
    putsay &quot;What is #{i} times #{j}?&quot;
    answer = gets.to_i
    num_questions += 1
    right = i*j
    if answer == right
      putsay &quot;Awesome!&quot;
      num_right += 1
    else
      putsay &quot;Wrong!&quot;
    end
    j += 2
  end
  i += 2
end
putsay &quot;You got #{num_right}&quot; +
&quot; out of #{num_questions}.&quot;</code></pre>
</div>
</figure>

</div>
